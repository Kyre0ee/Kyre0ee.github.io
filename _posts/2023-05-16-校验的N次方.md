---
layout: post
title: 6.校验的N次方-签名校验对抗的多种姿势、PM代理、IO重定向
date: 2023-05-16 15:57 +0800
tags: 安卓逆向
expert: "记录签名校验相关的学习笔记。"
toc: true
---
# 1.什么是校验
***
校验是开发者在数据传送时采用的一种校正数据的方式，常见的校验有：** 签名校验 **、dexcrc校验、apk完整性校验、路径文件校验等
# 2.什么是APK签名
***
通过对Apk进行签名，开发者可以证明对Apk的所有权和控制权，可用于安装和更新其应用。而在Android设备上的安装Apk,如果是一个没有被签名的Apk,则会被拒绝安装。在安装Apk的时候，软件包管理器也会验证Apk是否已经被正确签名，并且通过签名证书和数据摘要验证是否合法没有被篡改。只有确认安全无篡改的情况下，才允许安装在设备上。

简单来说，Apk的签名主要作用有两个：
1. 证明APK的所有者
2. 允许Android市场和设备校验APK的正确性
Android目前支持以下四种应用签名方案：
* V1方案： 基于JAR签名
* V2方案： APK签名v2
* V3方案： APK签名v3
* V4方案： APK签名v4
V1签名的机制主要就在META-INF目录下的三个文件，MANIFEST.MF,ANDROID.SF,ANDROID.RSA,它们都是V1签名的产物
* (1)MANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件（entry）,对非文件夹签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的校验信息不同，于是程序就不能成功安装。
* (2)c.SF: 这是对摘要的签名文件，对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。
* (3)ANDROID.RSA: 文件中保存了公钥，所采用的加密算法等信息。
在某些情况下，直接对apk进行v1签名可以绕过apk的签名校验。v2方案会将APK文件视为blob,并对整个文件进行签名检查，对APK进行的任何修改（包括对zip元数据进行的修改）都会使APK签名作废。这种形式的APK验证不仅速度要快得多，而且能够发现更多种未经授权的修改。
# 3.什么是签名校验
如何判断是否有签名校验？不做任何修改，直接签名安装，应用闪退则说明大概率有签名校验。
普通的签名校验会导致软件的闪退、黑屏、卡启动页等，有些签名校验会直接rm -rf/,把基带都格式掉，比如三角校验（so检测dex,动态加载的dex）
> kill/killProcess----可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉），当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常kill,它会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因。
> system.exit----杀死了整个进程，这时候活动所占的资源也会被释放。
> finish----仅仅针对Activity,当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理。
普通获取签名校验代码：
`private boolean SignCheck() {
    String trueSignMD5 = "d0add9987c7c84aeb7198c3ff26ca152";
    String nowSignMD5 = "";
    try {
        //得到签名的MD5
        PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),PackageManager.GET_SIGNATURES);
        Signature[] signs = packageInfo.signatures;
        String signBase64 = Base64Util.encodeToString(signs[0].toByteArray());
        nowSignMD5 = MD5Utils.MD5(signBase64);
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        }
        return trueSignMD5.equals(nowSignMD5);
}`
系统将应用的签名信息封装在PackageInfo中，调用PackageManager的getPackageInfo(String packageName, int flags)即可获取指定包名的签名信息。
# 4.签名校验对抗
***
* 方法1：核心破解插件，不签名安装应用
* 方法2： 一键过签名工具，例如MT、NP、ARMPro、CNFIX、Modex的去除签名校验功能。
* 方法3： 具体分析签名校验逻辑（手撕签名校验）1.通过闪退逻辑定位 2.拦截获取签名的信息堆栈
* 方法4： io重定向--VA&SVC: ptrace+seccomp
# 5.手动实现PM代理
## 5.1 什么时PMS
PackageManagerService(简称PMS),是Android系统核心服务之一，处理包管理相关的工作，常见的比如安装，卸载应用等。
## 5.2 实现方法以及原理分析
HOOK PMS代码：
`
package com.zj.hookpms;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

import android.content.Context;
import android.content.pm.PackageManager;
import android.util.Log;

public class ServiceManagerWraper {
    public final static String ZJ = "ZJ595";
    
    public static void hookPMS(Context context, String signed, String appPkgName, int hashCode) {
    try {
    //获取去安居的ActivityThread对象
    Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");
    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod("currentActivityThread");
    object currentActivityThread = currentActivityThreadMethod.invoke(null);
    //获取ActivityThread里面的原始的spackageManager
    Field sPackageManagerField = activityThreadClass.getDeclaredField("sPackageManager");
    sPackageManagerField.setAccessible(true);
    object sPackagemanager = sPackageManagerField.get(currentActivityThread);
    //准备好代理对象，用来替换原始对象
    Class<?> iPackageManagerInterface = Class.forName("android.content.pm.IPackageManager");
    object proxy = proxy.newProxyInstance(
             iPackagemanagerinterface.getClassLoader(), new Class<?>[]{iPackageManagerInterface},
             new PmsHookBinderIncocationHandler(sPackageManager, signed,appPkgName, 0));
             
    //1.替换掉ActivityThread里面的sPackageManager 字段
    sPackagemanagerField.set(currentActivityThread, proxy);
    //2.替换ApplicationPackageManager里面的mPM对象
    PackageManager pm = context.getPackageManager();
    Field mpmField = pm.getClass().getDeclaredField("mPM");
    mpmField.stAccessible(true);
    mpmField.set(pm,proxy);
    } catch (Exception e) {
        log.d(ZJ, "hook pms error:" + Log.getStackTraceString(e));
    }
    }
public static void hookPMS(context context) {
    String Sign = "原包的签名信息"；
    hookPMS(context, Sign, "com.zj.hookpms",0);
    }
}    
`
ActicityThread的静态变量sPackageManager,ApplicationPackageManager对象里面的mPM变量
# 6.IO重定向
***
## 6.1什么是IO重定向？
在读取A文件的时候指向B文件
## 6.2 IO重定向可以干嘛？
可以让文件只读，不可写
禁止访问文件
路径替换
具体实现：
过签名检测（读取原包）、风控对抗、过Root检测，Xposed检测
hook了open、openat、fopen、syscall、NR_openat等底层读取文件的函数
# 7.常见的检测
## 7.1 root检测 
1. 检查设备的build tags 是否包含test-keys。这通常是用于检测的设备，因此如果检测到这个标记，则可以认为设备已被root.
2. 检查设备是否存在一些特定的文件，这些文件通常被用于执行root操作。如果检测到这些文件，则可以认为设备已被root.
3. 使用Runtime.exec()方法来执行which su命令，然后检查命令的输出是否不为空。如果输出不为空，则可以认为设备已被root.
## 7.2怎么去除root检测 
1. 找到源码中对应的方法让它返回false 
2. 算法助手->隐藏root、隐藏xposed
3. IO重定向，让它获取不到一些文件
4. 修改安卓的底层源码
## 7.3模拟器检测 
1. 通过检测系统的Build对象来判断当前设备是否为模拟器。具体方法是检测Build.FINGERPRINT属性是否包含字符串“generic”
## 7.4反调试检测 
安卓系统自带调试检测函数
## 7.5ptrace检测
每个进程同时刻只能被1个调试进程ptrace,主动ptrace本进程可以使得其他调试器无法调试。
## 7.6frida检测




