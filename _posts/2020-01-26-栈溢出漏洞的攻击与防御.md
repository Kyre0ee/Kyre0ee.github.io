---
layout: post
title: 栈溢出漏洞的攻击与防御
date: 2020-01-26 09:30
tags: 二进制安全
excerpt: "本文介绍二进制安全漏洞-栈溢出漏洞的攻击与防御。"
toc: true
---	
# 栈溢出漏洞 (Stack Overflow Vulnerability) 

## 描述

栈溢出漏洞是指当向栈中写入的数据超过了栈的容量，导致覆盖了相邻内存区域的数据。这种覆盖可能会改变程序的控制流，导致执行任意代码。栈溢出是最常见的内存管理漏洞之一，尤其在C和C++等不提供自动边界检查的语言中更为常见。

## 案例

### 漏洞代码示例

以下是一个简单的C语言程序，该程序存在栈溢出漏洞：

```c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *str) {
    char buffer[10];
    strcpy(buffer, str); // 没有检查输入长度
}

int main() {
    char large_string[50];
    memset(large_string, 'A', 49);
    large_string[49] = '\0';
    vulnerable_function(large_string);
    return 0;
}
```

在上述代码中，large_string的长度超过了buffer的容量，这会导致栈溢出。

## 漏洞利用

攻击者可以利用栈溢出漏洞覆盖栈上的返回地址，从而控制程序的执行流。具体利用方式依赖于程序的内存布局，但通常包括以下步骤：

- 触发栈溢出：通过特定输入触发栈溢出，覆盖返回地址。
- 注入恶意代码：在输入中包含恶意代码或指向恶意代码的地址。
- 劫持控制流：通过覆盖的返回地址，将控制流转移到恶意代码处。

## 实例利用

考虑一个更复杂的例子，其中栈溢出被利用来执行任意代码：

```c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *str) {
    char buffer[50];
    strcpy(buffer, str); // 没有检查输入长度
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    vulnerable_function(argv[1]);
    return 0;
}
```

攻击者可以输入一个超长字符串，其中包含恶意代码或地址，从而实现攻击目的。

## 防御手段

### 使用安全函数

使用带有边界检查的函数，如strncpy代替strcpy，snprintf代替sprintf等：

```c
strncpy(buffer, str, sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0'; // 确保字符串终止
```

### 启用编译器保护

启用编译器的安全选项，如栈保护（Stack Canaries），可以在栈上插入保护变量，在检测到溢出时终止程序：

```bash
gcc -fstack-protector-all -o program program.c
```

### 地址空间布局随机化 (ASLR)

启用ASLR，增加攻击者预测内存地址的难度：

```bash
echo 2 > /proc/sys/kernel/randomize_va_space
```

### 不可执行栈

配置栈为不可执行（NX或DEP），防止栈上的代码被执行：

```bash
gcc -z noexecstack -o program program.c
```

### 使用现代编程语言

使用具有自动边界检查的现代编程语言，如Python、Java等，减少手动内存管理错误：

```python
# Python自动处理边界检查
buffer = "safe string"
```

### 代码审计和静态分析

进行代码审计和使用静态分析工具，检测潜在的缓冲区溢出漏洞：

- Coverity
- Clang Static Analyzer

## 总结

栈溢出漏洞是二进制安全中常见且危险的漏洞之一。通过良好的编码习惯、使用安全函数、启用编译器保护和地址随机化等措施，可以有效防范栈溢出漏洞。理解栈溢出的原理及其危害，能够帮助开发者编写更加安全的代码，避免潜在的安全风险。

```c
// ### 漏洞代码示例
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *str) {
    char buffer[10];
    strcpy(buffer, str); // 没有检查输入长度
}

int main() {
    char large_string[50];
    memset(large_string, 'A', 49);
    large_string[49] = '\0';
    vulnerable_function(large_string);
    return 0;
}
```

```c
// 更复杂的利用示例
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *str) {
    char buffer[50];
    strcpy(buffer, str); // 没有检查输入长度
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    vulnerable_function(argv[1]);
    return 0;
}
```

```bash
# 启用栈保护
gcc -fstack-protector-all -o program program.c


# 启用ASLR
echo 2 > /proc/sys/kernel/randomize_va_space

# 配置不可执行栈
gcc -z noexecstack -o program program.c
```
