## yara学习

### Yara源码分析&调试

#### 1.源码安装

       $ git clone [https://github.com/VirusTotal/yara.git](https://github.com/VirusTotal/yara.git)

       ./build.sh    //修改文件中第二个命令行为.configure –enable-debug

编译执行之后可执行文件在.libs目录下

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)

#### 2.静态源码分析

从yara.c的主函数开始分析，将过程分为三个阶段：1.调用yr_initialize函数进行初始化操作

2.加载&编译规则文件 3.扫描

##### 1.初始化

调用yr_initialize函数进行初始化库，该函数将分配库所需的所有资源并初始化内部数据结构，只有主线程需要调用该函数，其他线程不用调用。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg)

##### 2.加载&编译规则文件

加载规则文件按照规则文件是否已编译分为两种处理情况，下面分析以规则文件未编译为主。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image005.jpg)

如上图，编译规则文件分为三步

1.首先调用yr_compiler_create创建一个规则编译器

2.为规则编译器设置回调函数

3.调用compile_file函数编译规则文件。

4.将编译好的规则返回给rules

5.销毁编译器

接下来主要分析compile_file编译规则文件过程。

###### 编译规则文件

跳转进入到common.c（cli）文件compile_files函数

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image007.jpg)

继续跟进compiler.c(libyara)的yr_compiler_add_file函数中，可以看到分为四步1.为编译器设置namespace 2.将当前规则文件名push进编译器文件名栈中3.规则解析并交给compiler编译器4.弹出当前规则文件名。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image009.jpg)

继续跟进lexer.c(libyara)yr_lex_parse_rules_file分析规则解析过程

lexer.c是规则的词法分析部分。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

grammar.y 是规则的语法分析部分。

Grammar.c(libyara)

yyparse函数(grammar.c) 种调用YYLEX获取标识符，当匹配到用户定义的BNF范式后进入一个大大的swithch，调用用户调用的各种归约函数(reduce_*):

接下来将详细分析yyparse函数的工作。如下图首先进入调用yysetstate部分

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg)

该部分用于设置单独的堆栈状态,不做详细分析

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg)

跳转到yybackup部分，如下图，可以看到首先调用了yylex获取标识符yychar。接着设置yytoken,接着按照yytoken的结果进行对应的操作。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg)

接着主要分析匹配到用户定义的BNF范式之后的操作。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg)

首先分析以下grammar.y文件中的对应关系。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg)

Case36: 调用yr_parser_reduce_string_declaration

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg)

Parser.c(libyara)

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg)

调用了yr_ac_add_string函数

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image026.jpg)

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image028.jpg)

###### 获取编译规则文件

Compiler.c

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg)

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image032.jpg)

Ahocorasick.c(libyara)

编译ac自动机分为三步，1.创建失效链接匹配 2.优化失效链接 3.创建转换表

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image033.png)

接下来分析创建失效链接

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image035.jpg)

##### 3.扫描

扫描过程主要步骤分为3步，1.创建一个扫描器将编译好的规则交给扫描器 2.为扫描器创建回调函数 3.扫描传入的扫描目录或列表或单个文件。（目录和扫描列表使用的是多线程扫描器）

###### scan_dir or scan_list

下图为扫描一个目录或者扫描列表

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image037.jpg)

###### scan_file

如下图，扫描单个文件分为三步1.创建扫描器 2.为扫描器设置回调函数 3.扫描文件

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image038.png)

接下来主要分析扫描文件的过程，调用yr_scanner_scan_fd，将需要扫描文件以文件描述符的方式打开

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image039.png)

在yr_scanner_scan_fd继续调用yr_scanner_scan_mem进行数据扫描

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image041.jpg)

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image043.jpg)

Scanner.c接着继续分析内存块扫描，在这个函数中分为四步1.创建了一个保存所有匹配的记录表2.接着为scanner进行各种与block相关的赋值3.为规则执行opcode的计算4.调用扫描器的回调函数。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image045.jpg)

yr_execute_code 执行rules_opcode

接下来看一下（libyara/exec.c）yr_execute_code函数，以switch case的方式指向规则的opcode

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image046.png)

看一下扫描上下文这个数据结构包含哪些信息

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image048.jpg)

调用扫描回调函数

在scanner.c(libyara)有两处调用回调函数

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image049.png)

在yara.c中我们可以看到为扫瞄器设置的回调函数是callback

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image051.jpg)

继续看一下handle_message，展示匹配后的信息

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image053.jpg)

##### 4.退出

销毁各种资源

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image054.png)

#### 3.动态gdb调试

设置调试参数

set args ../tests/data/test.yar ../tests/data/test

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image056.jpg)

设置带调试信息的动态库

set environment LD_LIBRARY_PATH=/home/kali/Desktop/yara/libyara/.libs

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image058.jpg)

语法分析器入口以及调用堆栈

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image060.jpg)

进入lexer.c文件调用YY_DECL完成扫描的主要功能的堆栈调用信息

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image062.jpg)

继续执行此时栈上可以看到规则文件的内容

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image064.jpg)

打印出yyg

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image066.jpg)

接着跳进了grammar.c文件的yara_yyparse函数中

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image068.jpg)

Yr_ac_compile函数的调用堆栈：

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image070.jpg)

在yr_scanner_scan_mem_blocks函数中可以看到从文件中获取data的过程

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image072.jpg)

Yr_get_entry_point_offset的调用堆栈如下

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image074.jpg)

_yr_scanner_scan_mem_block 传入的block->size是需要扫描的文件的大小

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image076.jpg)

//是不是可以理解为扫描的文件是以块block的形式读入然后进行匹配。？？？

最终调用scanner –>callback函数，函数调用堆栈如下图所示。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image078.jpg)

yr_scan_verify_match扫描匹配函数的调用堆栈

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image080.jpg)

_yr_atoms_tree_node_create函数调用堆栈

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image082.jpg)

yr_atoms_extract_from_string函数调用堆栈

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image084.jpg)

##### 构造ac失效匹配

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image086.jpg)

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image088.jpg)

迭代当前状态可以转换的所有状态，在当前状态输入t时第一个可以成功可转移的状态是e(test)

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image089.png)

zky（当前状态为k时第一个成功可转移状态为y）

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image090.png)

##### 优化失效匹配

 ![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image092.jpg)

##### yr_execute_code执行过程

yr_execute_code调用堆栈如下：

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image094.jpg)

1.首先是opcode=0x1c=28进行初始化规则，如果规则被禁用则跳过它的代码，否则跳转相应字节

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image096.jpg)

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image098.jpg)

。。。省略一些步骤

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image100.jpg)

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image102.jpg)

### Aho-Corasick automaton算法学习

AC自动机算法分为3步：

1.构造一颗trie树

2.构造失效指针（失效指针，为了节省匹配次数，不放弃已匹配过的部分，AC自动机之中加入了fail路径，失效指针能够在节点无法匹配下个字符的时候，转向其他节点。）

失配指针是如何构建的呢？

3.模拟匹配过程

AC算法有3个核心函数，分别是：

Success;成功转移到另一个状态（也称goto表或success表）

Failure:不可顺着字符串跳转的话，则跳转到一个特定的节点（也称failure表），从根节点到这个特定的节点的路径恰好是失败前的文本的一部分。

Emits:命中一个模式串（也称output表）

1.添加关键词到tire树中

2.构建自动机，失效函数

3.检索状态机直到匹配

 3.若当前节点是根且存在状态转移，则说明是匹配词的开头，记录词的起始位置

 若为状态词的结尾，则把词放进结果集中。

匹配过程：

自动机从根节点0出发

1.首先尝试按success表转移（图中实线）。按照文本的指示转移，也就是接收一个u。此时success表中并没有相应路线，转移失败。

2.失败了则按照failure表回去（图中虚线）。按照文本指示，这次接收一个s,转移到状态3.

3.成功了继续按success表转移，直到失败跳转步骤2，或者遇到output表中标明的“可输出状态（图中红色状态）”。此时输出匹配到的模式串，然后将次状态视作普通的状态继续转移。

算法高效之处在于，当自动机接受了“ushe”之后，再接收一个r会导致无法按照success表转移，此时自动机会聪明地按照failure表转移到2号状态，并经过几次转移后输出“hers”.来到2号状态地路不止一条，从根节点一路往下，“h->e”也可以到达。而这个“he”恰好是“ushe”的结尾，状态机就仿佛是压根就没失败过（没有接收r）,也没有接受过中间的字符“us”,直接就从初始状态按照“he”的路径走过来一样（到达同一节点，状态完全相同）。

Success\failure\output表很厉害它们是怎么计算出来的呢？

Success表实质上就是一个trie树。

Output表也很简单，与trie树里面代表这个节点是否是单词结尾的结构很像。不过trie树只有叶节点才有output，并且一个叶节点只有一个output。（output会在建立failure表的时候进行一次扩充）。

Failure表，这个表是trie树没有的，加了这个表，AC自动机就看起来不像一颗树，而像一个图了。Failure表是状态与状态的一对一关系，节点只会发出一条虚线，它们严格一对一。

这个表的构造方法是：

1.首先规定与状态0距离为1（即深度为1）的所有状态的fail值都为0.

2.然后设当前状态是s1,求fail(S1),S1的前一状态必定是唯一的（刚才说的一对一），设S1的前一状态是S2,,s2转换到S1的条件为接受字符C,测试S3=goto(fail(S2),c).

3.如果成功，则fail(S1)=goto(fail(s2),c)=s3

4.如果不成功，继续测试S4=goto(fail(s3),c)是否成功，如此重复，直到转换到某个有效的状态Sn,令fail(s1)=sn

理解过程参考链接：

https://blog.csdn.net/sa14023053/article/details/52073254

https://zhuanlan.zhihu.com/p/368184958

### 暴力匹配学习&理解

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image103.png)

### KMP算法学习&理解

Kmp算法是一种字符串匹配算法，Knuth-Morris-Pratt字符串查找算法，简称为KMP算法，常用于在一个文本串S内查找一个模式串P的出现位置。

Next数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next[j]=k,代表j之前的字符串中有最大长度为k的相同前缀后缀。也就意味着在某个字符失配时，该字符对应的next值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next[j]的位置）。如果next[j]等于0或-1，则跳到模式串的开头字符，若next[j]=k且k>0,代表下次匹配跳到j之前的某个字符，而不是跳到开头，且具体跳过了k个字符。

参考链接：

https://blog.csdn.net/v_JULY_v/article/details/7041827?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166631614916782391849713%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166631614916782391849713&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-7041827-null-null.142^v59^new_blog_pos_by_title,201^v3^control_1&utm_term=KMP&spm=1018.2226