---
layout: post
title: 操作系统7个大题
date: 2024-05-24 09:30
tags: 操作系统
toc: true
---
# 地址变换和求fat表大小
## 1.地址变换
1.先将给出的逻辑地址转换为二进制
2.从后往前数把页面大小位数的排除，剩余部分转化成页表对应位置的值
3.拼接-转换为16进制数
例1：某一页表内容自0~7依次为03；07；0B;11;1A;1D;20;22。请计算页面大小为1K和4K时的逻辑地址134D对应的物理地址。
解：134D = 0001 0011 0100 1101
    1K = 2^10  找到页表中块号：000100(第4个位置) 1A=1010  拼接：0010 1011 0100 1101 = 2B4DH
    4K = 2^12  找到页表中块号：  0001(第1个位置) 07=0111  拼接：0111 0011 0100 1101 = 734DH  
## 2.FAT表大小
1.确定多少个磁盘块
2.文件分配表，有多少个目录，目录大小
3.目录大小 X 目录数
例1：假定磁盘块的大小为1K,对于540M的硬盘，其文件分配表FAT需要占用多少存储空间？当硬盘容量为1.2G，FAT需要占用多少空间？
解： 540M/1K = 540K(个)磁盘块  512<540<1024 1024K = 2^20   磁盘块需要用20位二进制表示 20/8 = 2.5个字节 540K X 2.5 = 1350K
     1.2G/1K = 1.2M(个)磁盘块  1M<1.2M<2M   2M = 2^21 磁盘需要用21位二进制表示  21/8 = 24/8 = 3个字节  1.2M X 3 = 3.6M
# 分区分配算法
1.先画表格 2.每次装入之后计得修改起始地址和分区大小
例1：在如下分区表的基础熵，按照首次适应和最佳适应二种算法一次分配五个进程P0、P1、P2、P3、P4时的进程开始地址。五个进程的大小为P0:200K P1:15K P2:100K P3:80K P4:20K
| 分区编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| :-- | :-- | :-- | :- | :- | :- | :- |
| 起始地址 | 10K | 200K | 250K | 320K | 500K | 850K |
| 分区大小 | 100k | 30k | 50K | 150K | 300K | 220K |

解：
|  | p0 | p1 | p2 | p3 | p4 |
| :-- | :-- | :-- | :- | :- | :- |
| 首次适应 | 500k | 10K | 320k | 25K | 200k |
| 最佳适应 | 850K | 1050k | 10k | 320k | 200k |
首次适应：从头到尾按地址分区的顺序进行分配，碰到第一个比他大的就装入
最佳适应：按块大小顺序
next适应：从当前顺序的下一个进行顺序查找分配
最坏适应：
# 页面置换算法
例：在一个请求分页系统中，有一个长度为5页的进程，假如系统为它分配3个物理块，并且此进程的页面走向为2，3，2，1，5，2，4，5，3，2，5，2。分别用FIFO,LRU,OPT算法分别计算出程序访问过程中所发生的缺页次数。
|   | FIFO  | LRU   | OPT |
| :-- | :-- | :-- | :--|
| 1 | 2 5 3 | 2 3 - | 2 4 |
| 2 | 3 2 5 | 3 5 - | 3 2 |
| 3 | 1 4 2 | 1 4 2 | 1 5 |
| 缺次| 9 | 7 | 6 | 

# 磁盘调度算法
例：某磁盘有8192个磁道，编号为0~8191，在完成了磁道1250处的请求后，当前正在磁道3500处为一个请求服务。若此时请求队列的先后顺序为1000，4000，3300，5600，1300，6000，1200，2500。回答下述问题：
（1）采用FCFS（先来先服务）算法完成上述请求。请写出磁头移动的顺序，并计算平均寻道长度。
（2）采用SSTF（最短寻道时间优先）算法完成上述请求。请写出磁头移动的顺序，并计算平均寻道长度。
（3）采用SCAN（电梯）算法完成上述请求。请写出磁头移动的顺序，并计算平均寻道长度。
 
  FCFS: 3500 1000 4000 3300 5600 1300 6000 1200 2500   2500+3000+700+2300+4300+4700+4800+1300 / 8 = 23600/8
  SSTF: 3500 3300 4000 2500 1300 1200 1000 5600 6000   200+700+1500+1200+100+200+4600+400 /8 = 8900/8
  SCAN: 3500 4000 5600 6000 3300 2500 1300 1200 1000   500+1600+400+2700+800+1200+100+200 /8 = 7500/8
 # 处理机调度算法
 例：分别计算按FCFS算法和SJF算法调度以下进程时的平均周转时间和平均带权周转时间。
 | 进程名称 | A | B | C | D | E |
 | :-- | :-- | :-- | :-- | :-- | :-- |
 | 到达时间 | 0 | 1 | 2 | 3 | 4 |
 | 服务时间 | 4 | 3 | 5 | 2 | 4 |
 先来先服务算法：
 FCFS: 到达时间0 1 2  3   4
       结束时间4 7 12 14  18
       周转时间4 6 10 11  14    周转时间=结束时间-到达时间
       服务时间4 3 5  2   4
       带权周转1 2 2  2.5 3.5   带权周转=周转时间/服务时间
短作业优先算法：
 SJF:  到达时间0 1  2  3  4
       结束时间4 9  18 6  13
       周转时间4 8  16 3  9                     = 8
       服务时间4 3  5  2  4
       带权周转1 8/3 16/5 3/2 9/4               = 2.124
高响应比优先算法： 响应比 = （等待时间+服务时间）/服务时间
# 银行家算法
例： 假定系统中有五个进程{p0,p1,p2,p3,p4}和三类资源{A,B,C},各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图所示。
（1）T0时刻的安全性
（2）p1请求资源：P1发出请求向量Request(1,0,2),系统按银行家算法进行检查
|     | MAX   | Allocation | Need  | Avalible |
| :-- | :-- | :-- | :-- | :-- |
| z   | A B C | A B C      | A B C | A B C    |
| p0  | 7 5 3 | 0 1 0      | 7 4 3 | 3 3 2    |
| p1  | 3 2 2 | 2 0 0      | 1 2 2 |          |
| p2  | 9 0 2 | 3 0 2      | 6 0 0 |          |
| p3  | 2 2 2 | 2 1 1      | 0 1 1 |          |
| p4  | 4 3 3 | 0 0 2      | 4 3 1 |          |
 解1：
  |    |  Work  | Need | Allocation | work+Allocation |  finish |
  |    |  ABC   | ABC  | ABC        |         ABC     |  ABC    |
  | p1 |  332   | 122  | 200        |         532     |  T    |
  | p3 |  532   | 011  | 211        |         743     |  T    |
  | p2 |  743   | 600  | 302        |        1045     |  T    |
  | p4 | 1045   | 431  | 002        |        1047     |  T    |
  | p0 | 1047   | 743  | 010        |        1057     |  T    |
  
(2) 102 < 122
    102 < 332 可以被分配
    安全性判断
|     | MAX   | Allocation | Need  | Avalible |
| :-- | :-- | :-- | :-- | :-- |
| z   | A B C | A B C      | A B C | A B C    |
| p0  | 7 5 3 | 0 1 0      | 7 4 3 | 2 3 0    |
| p1  | 3 2 2 | 3 0 2      | 0 2 0 |          |
| p2  | 9 0 2 | 3 0 2      | 6 0 0 |          |
| p3  | 2 2 2 | 2 1 1      | 0 1 1 |          |
| p4  | 4 3 3 | 0 0 2      | 4 3 1 |          |

  |    |  Work  | Need | Allocation | work+Allocation |  finish |
  |    |  ABC   | ABC  | ABC        |         ABC     |  ABC    |
  | p1 |  230   | 020  | 302        |         532     |  T    |
  | p3 |  532   | 011  | 211        |         743     |  T    |
  | p2 |  743   | 600  | 302        |        1045     |  T    |
  | p4 | 1045   | 431  | 002        |        1047     |  T    |
  | p0 | 1047   | 743  | 010        |        1057     |  T    |
 # 进程的同步和互斥（PV操作）  
   系统运行有三个进程：输入进程、计算进程和打印进程，它们协同完成工作。输入进程和计算进程之间共用缓冲区buffer1,计算进程和打印进程之间共用缓冲区buffer2.输入进程接收外部数据放入buffer1中，计算进程从buffer1中取出数据进行计算，然后将结果放入buffer2；打印进程从buffer2取出数据打印输出。用算法描述这三个进程的工作情况，并用wait和signal原语实现其同步操作。
   信号量：
   2个缓冲区，两个互斥信号量，其中一个进程使用时另一进程不允许使用
   每个缓冲区定义2个同步信号量

   semaphore mutex1=1, mutex2=2,empty1=1,empty2=1,full1=0,full2=0;
  ` void InP()
   {
     while(1)
     {
         wait(empty1);
         wait(mutex1);
         input a data from keyboard;
         Add to buffer1;
         signal(mutex1);
         signal(full1);
         }
         } `
         
   
   
   
