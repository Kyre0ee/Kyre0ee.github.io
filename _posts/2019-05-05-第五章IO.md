---
layout: post
title: 第五章 IO
date: 2019-05-05 15:57 +0800
tags: 计组-MIPS汇编
toc: true
---
# 第五章
***
## 1.IO系统概述
* 什么是输入输出系统？
  - 用来控制外设与主机（内存或CPU内的寄存器）之间进行数据交换的系统
  - 通常把外设及其控制电路、I/O总线等I/O硬件以及I/O软件统称为输入输出系统。
  - 也即：输入输出系统由I/O硬件和I/O软件两部分组成，它最典型地反映了硬件与软件地结合
* 用户程序、C函数和内核
  用户程序总是通过某种I/O函数或I/O操作符请求I/O操作。例如，读一个磁盘文件记录时，可调用C标准I/O函数fread()，也可直接调用系统调用封装函数read()来提出I/O请求。不管是C库函数、API函数或系统调用封装函数，最终都通过操作系统内核提供地系统调用来实现I/O.
  ![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/3ff7b59f-697a-4512-a6c0-ecc32b95fd27)
* IO系统层次结构
  从用户I/O软件切换到内核I/O软件的唯一办法是异常机制：系统调用（自陷）
  ![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/0f166fd2-6a34-4e76-b69d-786b29b47343)
* I/O系统概述
  - 各类用户的I/O请求需要通过某种方式传给OS:
    最终用户：键盘、鼠标通过操作界面传递给OS
    用户程序：通过函数（高级语言）转换为系统调用传递给OS
    I/O软件被组织成从高到低的四个层次，层次越低，则越接近设备而越远离用户程序。这四个层次依次为：
    （1）用户层I/O软件（I/O函数调用系统调用）
    （2）与设备无关的操作系统I/O软件
    （3）设备驱动程序
    （4）I/O中断处理程序
    大部分I/O软件都属于操作系统内核态程序，最初的I/O请求在用户程序中提出。
  - 输入输出系统解决哪些问题？
    + 软件如何管理各种外部设备？--操作系统课程的内容
    + 硬件如何实现各种信息的输入和输出
    + 硬件要实现上述功能需解决以下一系列问题：
      怎样在CPU、主存和外设间建立高效信息传输通路；
      怎样将用户的I/O请求转换成设备的命令；
      如何对外设进行寻址，使CPU方便地寻找到要访问地外设；
      I/O硬件和I/O软件如何协调完成主机和外设间数据传送；
## 2.外部设备
![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/4eef587c-fa64-403c-a658-5b9c7ce5a3fe)
外部设备地分类

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/aacb1570-4f28-493f-8802-99b86fb56d34)


![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/03e2a79a-c618-44ba-99cd-2287bd2f9939)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/acd887dc-e0f4-495c-8292-5f46938b9570)
如何把用户I/O请求转换为对设备控制命令并完成设备I/O任务，需要I/O软件与I/O硬件之间地协调工作。

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/f41c90cb-7556-4621-9897-c742c2e43bd9)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/e9deeb53-5bea-4522-9f86-59f14e62ad64)

## 3.IO接口
* 为什么要引入I/O接口？
  主机和外设地工作方式不同，而且各种外设使用地工作方式也不同。在CPU中并入所有地控制逻辑不切实际。
  外设的数据传送比CPU和主存慢的多，直接使用高速的系统总线连接外设不切实际。
  外设使用的数据格式和主机不同，需实现串-并转换。
  所以，要用一种专门机构来协调外设和主机间的信息交换过程。具有这种功能的一类机构就是I/O接口。

  ![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/7f87d00d-216f-4871-9a3c-40d0dc6983ab)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/3ada3c74-1947-4dff-9553-79e975c29d4a)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/52b8dd98-aa0d-4cdf-8018-269377b16f9f)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/4b167bb7-496c-458e-bec9-539cd2efd47f)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/5f85a3c9-40a4-4b70-8dc3-eba3329c5f22)
* IO端口的编址
  I/O设备寻址是解决主机与外设通信的一个必要环节:IO接口为信息交换提供了有效通路，CPU要找到需交换信息的设备，应解决：怎样将用户的IO请求转换成设备的命令；如何对外设进行编址；怎样使CPU方便地寻找到要访问地外设。
  IO设备地寻址实际上是对IO端口地寻址。对IO端口写可认为是向IO设备送出命令或数据。从IO端口读可认为是从设备取得数据或状态。一个IO接口可能会占有多个端口地址。
  CPU并不能直接访问外设，而是通过对IO端口地访问来控制外设。
* IO端口地编址方式
  （1）统一编址方式
  与主存地址空间统一编址。即：将主存地址地编号分出一部分给IO端口。因为这种方法将IO端口映射到主存空间的某个地址上，所以，也被称为存储器映射方式。例如，MIPS、Motorola处理器就采用该方案。
  （2）独立编址方式
  不和主存单元一起编号，而是对所有IO端口单独进行编号，使它们成为一个独立的IO地址空间。
外设和主机需要进行数据传送，如何控制进行数据传送呢？
键盘、鼠标等输入设备如何输入数据到主机？
主机如何输出数据到显示器、打印机等输出设备？
外设的数据传送控制方式有以下三种。
## 4.程序直接控制方式
基本思想：直接通过程序来控制主机和外设的数据交换。
数据传送有两种类型：
1. 无条件传送（同步方式）：对简单外设在规定时间用相应的IO指令进行信息的输入或输出。其实质是用程序来定时同步传送数据，适合于各类巡回检测或过程控制。
2. 条件传送（异步方式）：在专门的查询程序中安排相应的IO指令，直接从IO接口中取得外设和接口的状态，如：就绪、忙、完成等，根据这些状态来控制外设和主机的信息交换。这是一种通过程序查询到的状态来控制数据传送的方式，所以也被称为程序查询方式。

 ![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/c468ad7c-b4da-4bcd-8192-db815455831b)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/c046dbde-847e-48d8-be3e-12d886ac6553)
IO设备包括IO控制器，会将自己的状态放入状态寄存器中。
OS阶段性地查询状态寄存器中的特定状态，以决定下一步动作。
如何判断就绪？如何等待？读取状态寄存器，判断特定位（1-就绪，0-未就绪）是否为1。
探寻期间，可一致不断查询，独占查询，也可定时查询，需保证数据不丢失。
独占查询的特点：简单、易控制、外围接口控制逻辑少。CPU与外设串行工作，效率低、速度慢、适合于慢速设备。查询开销极大CPU完全在等待外设完成。
工作方式：完全串行或部分串行，CPU用100%的时间为IO服务。
## 5.程序中断控制方式
基本思想：当外设准备好时，便向CPU发中断请求，CPU响应后，中止现行程序的执行，转入中断服务程序进行输入输出操作，易实现主机和外设接口之间的数据传送，并启动外设工作。中断服务程序执行完成后，返回原被中止的程序断点处继续执行。此时，外设和CPU并行工作。

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/33be925f-8850-413d-ac94-14fcb0337ad9)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/bc5fe083-f264-4ea9-b281-eff146700cf8)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/ae73dfda-2e99-4260-b692-fa449c6fda6a)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/24eac869-b7e7-4a50-9b05-309ef4e91fa7)

中断响应的结果就是调出相应的中断服务程序。中断处理是指执行相应中断服务程序的过程。
不同的中断源其对应得中断服务程序不同。
典型得多重中断处理分为三个阶段：
- 先行段（准备阶段）：保护现场及旧屏蔽字，查明原因（软件识别中断时）、设置新屏蔽字、开中断
- 本体段（具体得中断处理阶段）
- 结束段（恢复阶段）：关中断、恢复现场及旧屏蔽字、清中断请求、开中断、中断返回
## 6.DMA方式
- DMA方式得基本思想：在高速外设和主存间直接传送数据。由专门硬件（DMA控制器）控制总线进行传输，DMA控制器是总线主控设备。
- DMA方式适用场合：高速设备、成批数据交换，且数据间间隔时间短，一旦启动，数据连续读写
- 采用请求响应方式：每当高速设备准备好数据就进行一次DMA请求，DMA控制器接受到DMA请求后，申请总线使用权。DMA控制器得总线使用优先级比CPU高，为什么？
- DMA方式与中断方式结合使用
CPU启动寻道或旋转后，CPU被调度执行其他程序，磁盘完成寻道或旋转操作后，向CPU发中断请求。在DMA控制器控制总线进行数据传送时，CPU执行其他程序。DMA传送结束时，通过DMA结束中断告知CPU。
DMA传送方式：DMA控制器和CPU共享主存，故可能出现两者争用主存得现象，为使两者协调使用主存，DMA可采用以下方式进行数据传送。
  - CPU停止法（成组传送）：DMA传输时，CPU脱离总线，停止访问主存，直到DMA传送一块数据结束。

    ![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/cdb8799b-046a-4e09-875d-bee90e73d002)

  - 周期挪用（窃取）法（单字传送）：DMA传输时，CPU让出一个总线事务周期，由DMA挪用来访问主存，传送完一个数据后立即释放总线。

    ![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/bd389279-a432-44fe-91bc-8ef1e63a05a2)
    IO设备要求DMA传送时，会遇到以下三种情况之一：
      - CPU不需要访问主存：不会发生冲突，两者并行。例如，CPU正在执行乘法指令，需要花很长时间，因而不需要马上访存。
      - CPU正在访问主存：必须等待存储周期结束，CPU让出总线，DMA才能访存
      - CPU同时要访问主存：出现访存冲突。因为不马上响应DMA请求得话，高速设备可能会发生数据丢失，所以DMA控制器得总线优先权比CPU高。这时，先让DMA占用总线，窃取一个主存周期，完成一个数据得交换。这样CPU便要延迟一段时间才能访存。
  - 交替分时访问法：每个存储周期分成两个时间片，一个给CPU，一个给DMA,在每个存储周期内，CPU和DMA都可访问存储器。

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/f762a067-62fe-452c-bf59-5f081a52c556)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/dcc9ed72-8029-4279-bab3-7a67806d348c)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/02ce5093-5c96-4083-a55c-0ff50aa9a3f3)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/2a6127dc-4a1b-4182-950a-ee4355082cb1)


![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/b3aa513d-fe06-4426-ba37-3dd114b1151d)

# 第五章 总结
***
