---
layout: post
title: DNS协议相关漏洞分析
date: 2021-06-26 09:30
tags: 漏洞分析
excerpt: "本文介绍 DNS协议相关漏洞分析以及检测建议。"
toc: true
---	

### 1.DNS协议相关

参考链接：[https://datatracker.ietf.org/doc/html/rfc1035（dns](https://datatracker.ietf.org/doc/html/rfc1035（dns)协议未扩展）
   [https://datatracker.ietf.org/doc/html/rfc2671（dns扩展机制EDNS0](https://datatracker.ietf.org/doc/html/rfc2671（dns扩展机制EDNS0)）

主机可以通过多种方式参与域名系统

        用户程序通过解析器与域名空间交互，用户查询和用户响应的格式特定于主机及其操作系统。用户查询通常是操作系统调用，并且解析器及其缓存将成为主机操作系统的一部分。能力较差的主机可能会选择将解析器实现为一个子程序，以便与需要其服务的每个程序链接。解析器使用他们通过对外部名称服务器和本地缓存的查询获得的信息来回答用户查询。

![](assets/image832.png)

主名称服务器通过从其本地文件系统读取主文件来获取有关一个或多个区域的信息，并回答有关从外部解析器到达的那些区域的查询。

![](assets/image833.png)

DNS 要求所有区域都由多个名称服务器冗余支持。指定的辅助服务器可以使用区域传输从主服务器获取区域并检查更新DNS 协议。名称服务器定期建立到外部名称服务器的虚拟电路，以获取区域的副本或检查现有副本是否未更改。发送的消息这些维护活动遵循与查询和响应相同的形式，但消息序列略有不同。

![](assets/image834.png)

![](assets/image835.png)

DNS查询和响应在DNS消息中传输，其结构如下

![](assets/image837.jpg)

A DNS Header has the following structure \[1\]:

![](assets/image839.jpg)

所有多字节整数都是网络字节顺序(大端序)。DNS消息的“Question”、“Answer”、“Authority”和“additional”部分都包含数量可变的资源记录(rr)。这些rr指定关于DNS资源和实体的详细信息。RR具有以下结构

![](assets/image841.jpg)

Question部分包含上述格式的rr，除了TTL、RDLENGTH和rdatfields被省略。

存在几种类型的rr，包括A (Type: \\x00\\x01), AAAA (Type: \\x00\\x1C), CNAME (Type: \\x00\\x05),DNAME (Type: \\x00\\x27)

查询报文如下：

![](assets/image843.jpg)

响应报文如下：

![](assets/image845.jpg)

#### 1.1  RR类型

##### 1.1.1 DNAME Records

委托名称记录(DNAME RR)用于为域名树的整个子树创建别名。考虑以下示例

![](assets/image847.jpg)

当尝试解析ftp.ca.example.com时(通过发出A查询)，服务器会注意到ca.example.com。有一个DNAME为example.com。因此，除了返回DNAME记录外，它还生成并返回一个合成的CNAME记录，该记录将ftp.ca.example.com别名为ftp.example.com。同时返回后者的Arecord，使客户端能够获取ftp.ca.example.com的IP地址。DNAME RR具有以下结构:

![](assets/image848.png)

BIND支持两个配置选项，以帮助防止DNS重新绑定攻击，即拒绝应答地址和拒绝应答别名。该报告特别重要的是deny-answer-aliases，如果CNAME或DNAME别名与配置的名称列表中的任何名称匹配，则丢弃来自上游DNS服务器的响应。

#### 1.2 DNS扩展

DNS安全扩展(DNSSEC)是一组规范，用于保护DNS提供的某些类型的信息。它为解析器提供了验证其接收到的信息的能力。名称服务器使用专用区域密钥对其响应进行数字签名，客户端使用公共区域密钥验证签名。Windows DNS API在Windows 8和Windows Server 2012中增加了对DNSSEC的支持。

##### 1.2.1 DNSSEC

DNSSEC是通过使用以下几种资源记录实现的

RRSIG -包含其他资源记录类型的加密签名。

DNSKEY—包含公钥。

NSEC-包含到区域中下一个记录名称的链接。

NSEC3 - 包含链接到区域中的下一个记录名作为NSEC，但NSEC3使用哈希记录名来避免区域枚举问题。

NSEC3PARAM -包含计算和确定哪些nsec3记录包括在响应DNSSEC请求的不存在的名称或类型的信息。

NSEC和NSEC3记录旨在为提供经过身份验证的DNS查询返回不存在的域“NXDOMAIN”作为回复。没有它们，中间人攻击者可以重放之前加密的nxdomain回复，并欺骗客户机认为域不存在。通过将NSEC记录指向下一个可用区域(按字母顺序排序)，可以解决这个问题。这为区域枚举打开了DNS数据库，NSEC3通过散列区域名称克服了这个问题。

###### RRSIG

RRSIG记录的样本A如下：

![](assets/image850.jpg)

RRSIG记录的格式为

![](assets/image852.jpg)

![](assets/image854.jpg)

![](assets/image856.jpg)

无论响应是正还是负，都会返回RRSIG记录，并且如果这些值包含了起始授权(SOA)、下一个安全记录(NSEC)或下一个安全记录版本3 (NSEC3)的记录类型，则会缓存这些值。

###### NSEC3

NSEC3 RR具有以下结构：

![](assets/image858.jpg)

NSEC3 RR中的所有者名称应该包含散列所有者名称的base32编码，并在区域名称前加一个标签。NSEC3 RR中的RDATA字段具有如下结构

![](assets/image860.jpg)

##### 1.2.2 未知类型

RFC 3597\[2\]为DNS引入了扩展机制，这样它就能够支持任意资源记录(RR)类型。未知类型和类的文本表示包含前缀“TYPE”(或“CLASS”)后跟一个无符号十进制整数。

![](assets/image862.jpg)

DNS分发信息的一种方式是使用区域传输。主DNS服务器向从服务器发送区域传输(一次全部或增量)，然后从服务器可以将区域信息提供给客户端。完全区域转移(AXFR)和增量区域转移(IXFR)最初分别在RFC 1034\[3\]和1035\[4\]中定义，尽管RFC 5936\[5\]取代了这两者。BIND命名服务器进程(named)可以以“原始”格式记录区域文件信息，这是在网络上传输区域的格式。例如，命名的配置片段

![](assets/image864.jpg)

可以用来指示named记录一个原始区域文件，如zoneaxfr。原始区域telussecuritylabs。AXFR交换从对AXFR记录的DNS查询开始。

AXFR查询是一个DNS查询，其中一个问题包含TYPE值为252。

##### 1.2.3 EDNS0

DNS的扩展机制(EDNS0)是附加部分中类型为OPT的伪rr。它用于扩展ddns以获得新的标志和响应码，例如用于DNSSEC，并促进更大(比默认512字节)的UDP数据报的使用。在EDNS0 OPTrecord中，有些字段如Class和TTL有不同的含义，其结构如下\[2\]

![](assets/image866.jpg)

EDNS0 OPT伪rr的RDATA字段包含0个或多个选项，每个选项包含Code、Length和data。

##### 1.2.4 名称权限指针(NAPTR)

Berkeley Internet Name Domain (BIND)是一个实现域名系统(DNS)的软件套件。它由互联网系统联盟(ISC)维护。named是BIND名称服务器进程(name守护进程)。

域名系统指定了许多资源记录类型，最常见的是a和AAAA记录类型，它们简单地将域名映射到IP地址。更复杂的资源记录类型是名称权限指针(NAPTR)\[2\]。这种类型的记录有很多用例，主要是因为它们能够通过使用正则表达式将多个记录链接在一起来生成复杂的动态生成的uri。NAPTR记录的语法如下
```

NAPTR <ORDER> <PREFERENCE> <FLAGS> <SERVICES> <REGEXP> <REPLACEMENT>

说明：

<ORDER>和<PREFERENCE>是用于确定要应用的规则的优先级的数字。

<FLAGS>字段用于控制记录中字段的重写和解释。,如。"u"可能表示终端URI。

<SERVICES>指定规则中考虑哪些应用程序。例如，“sip+E2U”可能用于aSIP重写规则，而“smtp+E2U”可能用于邮件重写规则。

<REGEXP>指定匹配和重写域名的正则表达式。

<REPLACEMENT>包含要查询的下一个域名，具体取决于flags字段。该字段与<REGEXP>字段互斥，并且仅根据历史原因提供。

例如，当查询e164电话号码“+1-770-555-1212”时，下面的NAPTR记录可能用于按顺序返回SIP或MAIL URI。
```


![](assets/image868.jpg)
```

“SIP+E2U”服务用例中的<REGEXP>为“!^.\*$! SIP:information@foo.se!i”。通常，regexp的格式如下

<DELIMITER><REGULAR\_EXPR><DELIMITER><SUBSTITUTION\_STR><DELIMITER><FLAGS>
```
在上面的示例中，分隔符字符是“!”。正则表达式“^.”\*$"匹配从行首到行尾的任何字符串(在本例中是E164phone号码)，并以不区分大小写的方式将其替换为"sip:information@foo.se"，该方式由"i"标志指定。正则表达式普遍用于指定正则语言，用特殊字符表示某些操作。有几个操作是允许的，并且有几个关于字符串如何与正则表达式匹配的警告。更多信息请参见\[3\]。

与此漏洞相关的是一个称为重复操作符的操作符子类。这些包括'\*'，'+'，'?’和边界操作符，当与正则表达式R一起使用时具有以下语义:

'R\*' -重复R 0次或多次。

'R+' -重复R一次或多次。

'R?' -重复R 0或R 1次。

bounds: 'R{n}'—重复R n次;'R{n，}' -至少重复R n次。'R{n,m}' -重复R n到m次

正则表达式指定正则语言，它恰好包含确定性有限自动机(DFA)\[4\]所接受的语言集合。DFA包含状态(指定了开始和结束状态)和由语言字母指定的状态之间的转换。当一个字符串被输入到DFA时，它从开始状态一个接一个地消耗字母，并根据转换图改变其状态。正则表达式“ab+a”可以用以下DFA表示


![](assets/image870.jpg)


在上面的图表中，状态表示为“|状态|”，符号表示为“(符号)”。正则表达式库，包括作为GNU libc一部分发布的正则表达式库，将正则表达式编译到DFA，然后使用该DFA执行字符串匹配。包含边界操作符(如“R{n}”)的正则表达式被编译为以下DFA

|Start| -----|DFA(R)|-----|DFA(R)|-----|DFA(R)|.....n times....|DFA(R)|-----|End|

其中DFA(R)是R正则表达式的DFA表示。

###### NAPTR

记录数据包含在Answer记录的RDATA字段中，其结构如下

![](assets/image872.jpg)

![](assets/image874.jpg)

检测设备应解析所有NAPTR记录，并检查Regex字段中的字符串。该字段包含一个正则表达式，格式如下

![](assets/image876.jpg)

NAPTR正则表达式允许除ASCII数字外的任何字符（\\x30-\\x39）,backslash(\\x5c)、NULL(\\x00) 作为<分隔符\>字段。检测设备必须识别分隔符字符，将Regex字符串分成其组成部分，从中获取Regex匹配子字符串。

### 2.DNS漏洞

#### CVE-2011-0414

##### 漏洞分析

当权威服务器处理成功的 IXFR 传输或动态更新时，有一小段时间窗口，在此期间 IXFR/更新与查询相结合可能会导致发生死锁。

##### 规则建议

![](assets/image878.jpg)

特征1：53端口响应

特征2：偏移2位匹配\\x80\\x00

说明：\\x80\\x00----Flags: 0x8000

特征3: \\x00\\xfb\\x00\\x01

说明:\\x00\\xfb---- Type: IXFR (incremental transfer) (251)

    \\x00\\x01---- Class: IN (0x0001) 

特征4：\\x00\\x01\\x00\\x01\\x00\\x01\\x51\\x80

说明：\\x00\\x01----Type: A (Host Address) (1)

      \\x00\\x01----Class: IN (0x0001)

\\x00\\x01\\x51\\x80----Time to live: 86400 (1 day)

#### CVE-2011-1889

##### 漏洞分析

前沿威胁管理网关2010 (Forefront Threat Management Gateway 2010, TMG)是一款针对MicrosoftWindows的网络安全保护解决方案。TMG提供三个主要特性。首先，路由和远程访问特性:Microsoft ForefrontTMG可以作为路由器、Internet网关、VPN服务器、NAT服务器和代理服务器。第二，安全特性:Microsoft Forefront TMG是一个防火墙，它可以检查网络流量，过滤掉不符合预定义安全策略的恶意软件和恶意内容。最后，TMG提供网络性能特性，包括web流量压缩和缓存。

TMG Firewall Client连接到Winsock API，监听发送到任何远程网络的请求。当对远程资源发出请求时，通信被拦截并转发到tmg防火墙，以便代理到远程目的地。如果请求是针对客户机本地网络上的一个资源，TMG Firewall client会简单地忽略该请求，通信将正常进行。在TMG防火墙客户端和服务器之间的Winsock代理功能是由“远程Winsock”协议支持的，该协议在TCP/1745。

Winsock是伯克利软件发行版UNIX套接字API的Windows实现，也被称为伯克利套接字或BSD套接字。在这两种情况下，这个API为应用程序开发人员提供了使用网络协议的方法，而不必管理每个协议或包的详细信息。

Winsock API定义了许多函数，其中之一是getHostByName()。getHostByName()函数从主机数据库中检索与主机名对应的主机信息。

Forefront TMG Client通过WSALookupServiceNext()钩子到Winsock API，它用于处理某些请求来解析DNS名称，包括那些用getHostByName()调用的请求。TMG客户机将名称解析请求传递给TMG服务器，后者试图提供一个解析。TMG客户端和服务器之间的请求和应答消息在所有消息中使用以下格式

![](assets/image880.jpg)

名称查询响应由Opcode 0x0f表示。对于具有此操作码的信息包，信息包在偏移量0x23处包含以下HOSTENTRY结构

![](assets/image882.jpg)

多字节整数是小端数，除非另有说明。

Forefront TMG 客户端中存在堆缓冲区溢出。 处理名称解析时存在漏洞来自 TMG 服务器的回复，其中回复的主机名过长。 应用程序分配一个缓冲区堆并将 0x64 (100) 字节的标头数据复制到缓冲区中，然后以 ASCII 格式回复主机名和 Unicode (UTF-16) 格式。 字符串分别由一个和两个空字节终止。 由于一个缓冲区大小计算错误，如果超过 216 个字节写入缓冲区，则缓冲区溢出标题。 由于每个 Unicode 字符需要两个字节，而 ASCII 需要一个字节，如果主机名回复长度超过 71 个字符，导致堆损坏可能让攻击者控制在函数指针上。

远程攻击者可以利用这个漏洞，强制安装了TMG Client的机器对过大的主机名进行查找(直接或通过别名)。不需要用户交互就可以利用这个漏洞，但最有可能的方法是诱使用户打开或浏览特定的文档或网页。成功的利用可能导致在当前登录用户的上下文中执行任意代码。

##### 规则建议

![](assets/image884.jpg)

特征1：53端口响应

特征2：偏移3位匹配\\x80

    说明：flags后8位为\\x80(10000000)

特征3: \\xC0\\x0C\\x00\\x05\\x00\\x01

说明:\\xC0\\x0C----name: xxxxxx

 \\x00\\x05---- Type: CNAME (Canonical NAME for an alias) (5)

  \\x00\\x01---- Class: IN (0x0001)

特征4：基于特征3跳过四字节，取两字节判断是否大于71

    说明：Data Length: 82 > 71

#### CVE-2011-1910

##### 漏洞分析

当缓存签名的负面响应信息时，BIND名称服务器进程(named)存在一个漏洞。分配一个4096字节的缓冲区用于处理SOA、NSEC、NSEC3记录及其相关的RRSIG记录。在记录处理循环中将记录数据的一些字段复制到这个缓冲区中，存在一个逐差错误。如果在记录类型被复制到缓冲区之前，这个缓冲区只剩下2个字节，那么“剩余大小”检查将通过，允许将2个字节的记录类型复制到缓冲区中，然后尝试复制一个额外的“信任”字节到缓冲区。这最后一个“信任”字节的副本将产生一个断言失败，因为缓冲区中没有剩余的空间。

包含SOA、NSEC或nsec3记录的恶意RRSIG记录数据的特别设计的恶意响应可以用来触发缓冲区溢出，导致断言失败和命名进程崩溃。

由于多个字段在多次转换后被复制到缓冲区中，精确的攻击检测在通用设备中是不可能的。然而，根据DNSSec标准列表和RFC 5702，支持的最大签名大小属于RSA算法家族，其DNSSec标准限制密钥大小为4096位，即512bytes。因此，任何RRSIG记录中的签名都不能超过512字节。

通用检测设备可以解析包含RRSIG记录的DNS报文，并验证签名字段的大小。如果发现该签名大于512字节，那么很可能正在进行利用该漏洞的攻击。

##### 规则建议

![](assets/image886.jpg)

特征1：53端口response

特征2：\\x00\\x2e\\x00\\x01

说明：\\x00\\x2e----Type: RRSIG (Resource Record Signature) (46)

      \\x00\\x01----Class: IN (0x0001)

特征3：基于特征2跳过两字节取两个字节判断是否大于512

说明：Data length: 3652

特征4：\\x00\\x06\\x05

说明：\\x00\\x06---- Type Covered: SOA (Start Of a zone of Authority) (6)

      \\x05---- Algorithm: RSA/SHA1 (5)

#### CVE-2011-2465

##### 漏洞分析

BIND的9.8.0版本引入了响应策略区域(Response Policy zone, RPZ)，它为DNS基础设施增加了一个安全级别和可问责性。RPZs是专门设计的区域，用于实现政策决策，例如恶意域的黑名单。RPZ响应包括返回不存在的域(NXDOMAIN)、无数据(NODATA)或替换资源记录集(RRSet replacement)形式的替代信息。(资源记录集(RRSet)是与域相关联的所有数据的集合。)

BIND RPZ配置的示例如下所示

![](assets/image888.jpg)

名称为的BIND名称服务器进程中存在拒绝服务漏洞。该漏洞是由于对配置为CNAME RRSet替换的RPZ执行某些查询时的断言失败。已知对记录类型RRSIG的查询会触发此漏洞，尽管其他记录类型也可能工作。远程的、未经身份验证的攻击者可以利用此漏洞在脆弱的服务器上造成拒绝服务条件。

该漏洞是服务器的配置导致的漏洞，客户端的RRSIG请求在攻击和正常情况下是相同的，无法通过流量特征检测该漏洞。

##### 规则建议

无法通过流量特征检测该漏洞。

#### CVE-2012-1667

##### 漏洞分析

AXFR响应由许多DNS消息组成，第一个消息应该包含最初的问题，第一个答案应该包含正在传输的区域的起始授权(SOA)记录。名称为的BIND名称服务器中存在拒绝服务漏洞。该漏洞是由于处理未知资源记录类型的零长度RDATA字段的方式。具体地说，当DNS服务器加载包含此类资源记录的原始区域文件时，将发生断言失败，终止已命名进程。

远程攻击者可以通过创建一个没有数据的未知资源记录来利用这个漏洞，该记录通过DNS系统传播。

##### 规则建议

![](assets/image890.jpg)

特征1：53端口response

特征2：偏移4位匹配\\x84\\x00

   说明：flags---\\x84\\x00

特征3：\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x00

   说明：\----Questions: 1

         \----Answer RRs: 2

         \----Authority RRs: 0

         \----Additional RRs: 0

特征4：\\x00\\x01+偏移4位+\\x00\\x00$

   说明：\\x00\\x01----Class: IN (0x0001)

         \\x00\\x00----Data length: 0

#### CVE-2012-5689

##### 漏洞分析

ISC BIND 9.8.x 到 9.8.4-P1 和 9.9.x 到 9.9.2-P1，在涉及 DNS64 的某些配置中，响应策略区缺少 AAAA 重写规则，允许远程攻击者导致拒绝服务（断言失败和命名守护程序退出）通过查询 AAAA 记录。

##### 规则建议

![](assets/image892.jpg)

特征1：53端口response

特征2：偏移3字节匹配\\x80\\x00\\x01\\x00\\x01

说明：\\x80 ---- Recursion available: Server can do recursive queries

      \\x00\\x01---- Questions: 1

      \\x00\\x01---- Answer RRs: 1

特征3：偏移大于11字节匹配\\x00\\x1c\\x00\\x01\\x00\\x00\\x2c\\x30

说明：\\x00\\x1c---- Type: AAAA (IPv6 Address) (28)

      \\x00\\x01---- Class: IN (0x0001)

      \\x00\\x00\\x2c\\x30---- Time to live: 11312 (3 hours, 8 minutes, 32 seconds)

#### CVE-2013-2266

##### 漏洞分析

正则表达式中使用的重复操作符可能导致相应dfa中的状态出现指数级爆炸。例如，如果上图中的R本身包含一个重复运算符“a{n}”，那么最终DFA中的状态总数将是O(n^2)。正则表达式等 "((((..((( {n} {n})) {n})……p次，{n})”将需要O(n^p)个州。这是不可避免的，因为DFA远不如图灵机强大，只能通过状态转换实现“计数器”。GNU libc允许n的最大值为255，但noupper限制p。因此即使适度值(n = 100)和p = 5在上面的例子中,statesof编译后的DFA的数量可以多达100亿,这是足够足够的排气memoryresources大多数计算机。

当BIND name服务器处理NAPTR类型的记录时，存在拒绝服务漏洞。为了清理传入的NAPTR记录，BIND验证NAPTR记录的`<REGEXP>`字段中的正则表达式是否有效。为此，它使用regex.h中定义的regcompfunction编译用户提供的正则表达式，该regcompfunction可在GNU libc的标准发行版中获得。regcomp内部维护aDFA，但对其状态的数量没有严格的限制，在编译恶意正则表达式时导致资源耗尽(内存和CPU)的情况。当系统耗尽内存时，命名进程被终止。

触发此漏洞的方法有多种。只要远程攻击者能够让运行漏洞版本BIND的目标服务器处理NAPTR记录，就会触发该漏洞。这里我们列出了远程攻击者触发此漏洞的两种可能场景

1.   远程攻击者运行自己的DNS服务器(提供恶意NAPTR记录)，并向注册商注册一个域名。他向目标DNS服务器发出一个DNS查询，目标DNS服务器递归地查询攻击者的DNS服务器。当响应沿着DNS服务器层次结构上升时，第一个处理此漏洞的脆弱服务器被终止。

2.  远程攻击者向第三方DNS提供商注册，该提供商允许他更新其域的记录，并运行一个非脆弱的DNS服务器。远程攻击者发出一个DNS动态更新，向其域添加恶意NAPTR记录。然后，他查询目标DNS服务器，目标DNS服务器递归地查询DNS提供者。当目标DNS服务器处理恶意记录时，该记录终止。

检测设备需要解析所有DNS Answer记录，查找NAPTR记录。这些记录在TYPE\\x00\\x23字段。

有两种方法可以确定Regex匹配是否是恶意的。在第一种方法中，检测设备必须能够运行C代码。检测设备必须创建子进程,然后尝试compilethis正则表达式匹配正则表达式使用regcomp GNU libc父进程的函数应该monitorthe子进程的内存使用情况,如果发现子进程使用过度的内存whileconverting DFA正则表达式匹配,那么交通就应该被认为是可疑的。

在第二种方法中，检测设备必须寻找Regex匹配中出现的嵌套重复操作符、“+”和边界。充分嵌套的“+”和边界(例如{n}，或{n，}或{n,m})操作符会导致指数级的dfa表示，所需嵌套级别的确切数量与上下文高度相关。如果检测设备能够确定嵌套内使用的字符串总长度的上限，以及系统可用内存支持的给定长度的嵌套层数，然后通过检查可以确定给定的Regex匹配字符串是否是恶意的，以及是否正在利用这个漏洞进行攻击。

注意，这两种方法所需的功能明显超出了当前检测系统的范围。

注意，所有多字节值都是网络(大端)格式。



##### 规则建议

![](assets/image894.jpg)


特征1：53端口响应

特征2：匹配\\x00\\x23\\x00\\x01

说明：\\x00\\x23---- Type: NAPTR (Naming Authority Pointer) (35)

   \\x00\\x01---- Class: IN (0x0001)

特征3：在特征2基础上偏移\>=10以正则方式匹配：

\\x21\[^\\x21\]+?\\x7b\[^\\x7d\\x21\]+?\\x7d\[\\x28\\x29\]\*?\\x7b\[^\\x7d\\x21\]+?\\x7d\[\\x28\\x29\]\*?\\x7b\[^\\x7d\\x21\]+?\\x7d

#### CVE-2015-8705

##### 漏洞分析

在 BIND 9.10 版本中，将 OPT 伪 RR 数据或 ECS 选项格式化为文本时可能会发生错误。在 9.10.3 到 9.10.3-P2 中，该问题可能导致 buffer.c 中的 REQUIRE 断言失败。在之前的 9.10 版本中，由于缓冲区溢出，可能会导致命名崩溃（例如分段错误）或其他不当行为。

##### 规则建议

![](assets/image896.jpg)

特征1：端口53 response

特征2：\\x85\\x80
说明：
\\x85\\x80---- Flags: 0x8580 Standard query response, No error

特征3：\\x00\\x29跳过两个字节匹配\\x00\\x00跳过四字节匹配\\x00\\x08
说明：
       \\x00\\x29---- Type: OPT (41)
    \\x00 ---- Higher bits in extended RCODE: 0x00
     \\x00 ---- EDNS0 version: 0
    \\x00\\x08----Option Code: CSUBNET - Client subnet (8)

#### CVE-2017-11779

Microsoft Windows Dnsapi.dll NSEC3 Buffer Overflow(CVE 2017-11779\_BID 101166\_ZDI 17-846)

##### 漏洞分析

Microsoft Windows的DNSAPI组件存在基于堆的缓冲区溢出漏洞。该漏洞是由于对响应DNS请求的NSEC3resource记录的RDATA中的Salt Length和Hash Length字段处理不当造成的。当使用DNS API的组件收到DNS请求的响应时，它会被DNS ExtractRecordsFromMessage()处理，并最终调用Dns ParseMessage()。Dns ParseMessage()为表中的每个记录类型查找处理函数，如果接收到的其中一条记录是NSEC3记录，则调用NSEC3 RecordRead()函数。Nsec3 RecordRead()通过从响应中接收到的下一个RR的指针减去指向Nsec3 RDATA中Salt字段的指针来计算缓冲区大小，该RR的地址是由Nsec3记录中的RDLENGTH字段确定的。该缓冲区通过调用Dns AllocateRecordEx()来分配，产生的缓冲区用于存储Salt的副本，接下来哈希所有者名称和类型位图字段。前面提到的每个字段都通过对memcpy()的单独调用进行复制。memcpy()的调用复制盐和接下来HashedOwner名称字段中使用前面的长度值RDATA字段(例如盐长度和散列)没有检查确保RDATA领域的总体规模大到足以包含盐或下HashedOwner给定长度的名字。因此，如果Salt Length或Hash Length字段的值大于RDATA字段中剩余的数据量，对memcpy()的调用将导致基于堆的缓冲区溢出。

用于复制类型位映射字段的memset()依赖于以下计算来确定要复制的字节数

![](assets/image897.png)

造成漏洞的原因：在Salt Length和Hash Length的组合值大于RDLENGTH-6的情况下，使用memcpy()作为size参数的值将会下溢并导致基于堆的缓冲区溢出，注意在这种情况下溢出的潜在大小是最大的。

未经身份验证的远程攻击者可以利用这个漏洞，对目标用户执行中间人攻击，或者危及目标用户的DNS服务器，然后发送带有经过制作的NSEC3记录的响应。成功的利用可能导致在执行DNS API调用的应用程序的安全上下文中执行任意代码。由于使用DNS API的系统服务数量众多，代码执行很有可能以system用户的身份实现。

注意，在响应中这样一个畸形的NSEC3记录极不可能被转发DNS服务器转发到客户端。

##### 规则建议

![](assets/image899.jpg)

特征1：53端口

特征2：偏移两位匹配\\x81\\xA0

说明：\\x81\\xA0----Flags: 0x81a0 Standard query response, No error

特征3：匹配\\x00\\x32\\x00\\x01\\x00\\x00\\x0e\\x0f

说明：\\x00\\x32 ---- Type: NSEC3 (50)

\\x00\\x01---- Class: IN (0x0001)

\\x00\\x00\\x0e\\x0f ---- Time to live: 3599 (59 minutes, 59 seconds)

特征4：基于特征3取两字节作为data的长度rr\_size

特征5：匹配\\x01\\x00\\x00\\x05

   说明：\\x01---- Hash algorithm: SHA-1 (1)

         \\x00---- NSEC3 flags: 0

         \\x00\\x05---- NSEC3 iterations: 5

特征6：剩余的长度!=rr\_size

#### CVE-2017-15908

##### 漏洞分析

systemd-resolve 中的 DNS 响应解析器在 NSEC 资源记录期间出现问题解析。

src/resolve/resolved-dns-packet.c 中的函数 dns\_packet\_read\_rr 根据类型读取资源记录。对于NSEC资源，下一个域名和类型位图（the types bitmaps）是从数据包中提取的。
```
case DNS\_TYPE\_NSEC: {

 bool allow\_compressed = p->protocol == DNS\_PROTOCOL\_MDNS;

 r = dns\_packet\_read\_name(p, &rr->nsec.next\_domain\_name, allow\_compressed, NULL);

 if (r < 0)

 return r;

 r = dns\_packet\_read\_type\_windows(p, &rr->nsec.types, offset + rdlength - p->rindex,NULL);

 /\* We accept empty NSEC bitmaps. The bit indicating the presence of the NSEC record

 \* itself is redundant and in e.g., RFC4956 this fact is used to define a use for NSEC

 \* records without the NSEC bit set. \*/

break;

 }
```
类型位图字段存储在窗口块中，函数dns\_packet\_read\_type\_windows 调用 dns\_packet\_read\_type\_window。 在这里存在一个无限解析 NSEC DNS 资源的循环：

函数 dns\_type\_is\_pseudo 检查类型是否在 \[0, TYPE\_ANY, TYPE\_AXFR, ... , \*\] 所以，通过在 NSEC 类型的资源记录中附加一个包含伪类型的类型位图应该在 systemd-resolve 服务中触发无限循环并导致 DOS。
```

static int dns\_packet\_read\_type\_window(DnsPacket \*p, Bitmap \*\*types, size\_t \*start) {

\[...\]

 /\* Read window and length from the packet \*/

 r = dns\_packet\_read(p, length, (const void \*\*)&bitmap, NULL);

 if (r < 0)

 return r;

 for (i = 0; i < length; i++) {

 uint8\_t bitmask = 1 << 7;

 if (!bitmap\[i\]) {

 found = false;

 bit += 8;

continue;

 }

 found = true;

 while (bitmask) {

 if (bitmap\[i\] & bitmask) {

 uint16\_t n;

 n = (uint16\_t) window << 8 | (uint16\_t) bit;

/\* Here the bitmask, bitmap and i are not modified from last iteration \*/

/\* dns\_type\_is\_pseudo doesn’t change them neither \*/

/\* so reaching this continue will result in a infinite loop \*/

 /\* Ignore pseudo-types. see RFC4034 section 4.1.2 \*/

if (dns\_type\_is\_pseudo(n))

 continue;

 r = bitmap\_set(\*types, n);

 if (r < 0)

 return r;

 }

 bit++;

bitmask >>= 1;

 }

 }

\[...\]

以下 Python PoC 适用于目标：

from scapy import \*

import socket

sock = socket.socket(socket.AF\_INET, socket.SOCK\_DGRAM)

sock.bind(('127.0.0.1', 53))

data, addr = sock.recvfrom(1024)

pkt = DNS(data)

attack = DNS(id=pkt\[DNS\].id, qr = 1, aa=1,\\

 qd=pkt\[DNS\].qd,\\

 an=DNSRR(rrname=ppkt\[DNSQR\].qname, ttl=10, rdata='8.8.8.8')\\

 /DNSRRNSEC(rrname='bad.fr', typebitmaps=RRlist2bitmap(\[0\])))

sock.sendto(str(attack), addr)
```
##### 规则建议

![](assets/image901.jpg)

特征1： 53端口response

特征1： 偏移4位匹配 \\x00\\x01\\x00\\x00\\x00\\x01

       说明: \\x00\\x01----Questions: 1

         \\x00\\x00----Answer RRs: 0

         \\x00\\x01----Authority RRs: 1

特征2： \\x00\\x2F + 偏移10位 +\\x20 + 偏移31位 + 匹配（\\x80|\\x40|\\x20|\\x10|\\x01|\\x08）（bitmask）

说明：\\x00\\x2F---- Type: NSEC (Next Secure) (47)

      \\x20---- Next Domain Name: <Root>

      \\x80|\\x40|\\x20|\\x10|\\x01|\\x08----RR type in bit map:

![](assets/image903.jpg)

特征1： 53端口

特征1： 偏移4位匹配 00 01 00 00 00 01 

特征2： 00 2F + 偏移10位 + 06 + 偏移5位 + 40（bitmap :OPT）

说明参考上一条规则。

#### CVE-2018-5740

##### 漏洞分析

ISC BIND中存在拒绝服务漏洞。该漏洞是由于在处理客户端DNAME或任何查询时，以及在服务器上配置了deny-answer-alias时，对来自上游DNS服务器的dnamerecord处理不当造成的。来自上游DNS服务器的响应由函数answer response()处理，该函数首先将查询名称与答案部分中每个提供的记录中的名称进行比较。在给定记录中的Owner名称与查询名称相同的情况下，answer response()确认该记录类型与查询类型匹配，即查询类型是“ANY”，或者记录类型是CNAME。在ANY或DNAME查询的情况下，允许拥有与查询名称相同的Owner名称的DNAME记录。

然后answer response()将通过调用answertarget allowed()函数来确认BIND配置允许DNAME目标。Is answertarget allowed()将首先检查是否为相关视图配置了deny-answer-aliasesis，如果配置了，将尝试分离请求名称的前缀部分。为了确定组成前缀的标签数量，计算DNAME记录中查询名和Owner名之间标签数量的差异。在这种情况下，标签的数量是相同的，如果查询的类型是ANY或DNAME，一个0的值将提供给后续调用dns name split()作为后缀标签参数，触发一个REQUIRE断言，确保后缀标签参数大于0并导致named终止。

一个远程的、未经身份验证的攻击者可以通过运行一个权威的DNS服务器，使目标服务器向攻击者控制的服务器发送一个ANY或DNAME查询，然后用一个具有与问题中名称相同的Owner名称的DNAME记录来响应这个漏洞。成功的开发结果是终止所命名的过程。

##### 规则建议

特征1： 53端口

特征1： 偏移2位匹配 81 80 00 01 00 01

说明：81 80----flags

      00 01 ----Questions:1

      00 01 ----Answer RRS:1

特征2：00 ff 00 01

说明： 00 ff ---- Type: \*(A request for …)

       00 01----Class: IN(0x0001)

特征3：00 27 00 01

说明：00 27 ----Type: DNAME(39)

      00 01 ----Class: IN (0x0001)

#### CVE-2018-5744

##### 漏洞分析

处理具有特定 EDNS 选项组合的消息时，可能会出现无法释放内存的情况。通过利用这种情况，攻击者可能会导致 named 的内存使用量无限增长，直到进程可用的所有内存都用完为止。通常，服务器进程可以使用的内存量是有限的，但如果指定进程不受操作系统限制，则服务器上的所有可用内存都可能耗尽。

##### 规则建议

![](assets/image905.jpg)

特征1：53端口DNS\_response

特征2：\\x00\\x30\\x00\\x01\\x00\\x00\\x29

说明：\\x00\\x30---- Type: DNSKEY (DNS Public Key) (48)

      \\x00\\x01---- Class: IN (0x0001)

      \\x00---- Name: <Root>

      \\x00\\x29---- Type: OPT (41)

特征3：基于特征2跳过12字节取2字节判断是否小于4

说明：Option Length: 2 < 4
					   

这个特征比较弱可能会存在误报的情况。

#### CVE-2018-16855

##### 漏洞分析

PowerDNS递归中存在整数下溢导致缓冲区过读漏洞。PowerDNS在接收到aDNS查询后，调用RecursorPacketCache::getResponsePacket()来检查是否可以从其缓存中获取响应。这个函数调用PacketCache::canHashPacket()来找到一个哈希值以索引到缓存中。PacketCache::canHashPacket()首先迭代DNS问题中记录中的名称，在迭代的同时增加指针p。此外，它还维护一个指针pos，指向DNS头后的第一个字节。如果在Additional Section中发现记录的数量是1，并且pos+16小于包的大小，PacketCache::canHashPacket()进入一个If -block来获得EDNS选项。数字16是数据包必须包含一个有效的OPT RR的问题名称之后的最小额外字节数。pos + 16但是，不提供该值，因为在遍历问题名时pos没有随p加1。因此，当恶意报文的OPT RR不完整时，可以通过该检查。接下来，在if块中，RecursorPacketCache::getResponsePacket()调用getEDNSOption()，将len(剩余数据包的长度)设置为end - p+14。如果数据包在DNS问题名称结束后小于14字节(不包括空终止符)，则发生整数下流，导致len成为一个非常大的值。这将导致绕过getEDNSOption()中的大小检查，促使该函数读取超出包缓冲区的数据以获得EDNS0选项，从而导致缓冲区过载。

远程攻击者可以通过向目标服务器发送精心制作的数据包来利用这个漏洞。成功的利用将导致pdns递归进程终止，导致拒绝服务的条件。

检测设备必须检查所有传入的DNS消息，其QR位设置为0和ARCOUNTset为1。对于这样的消息，检测设备必须继续跳过Question(包含一个以空结尾的Name、Type和Class)记录。如果DNS消息的剩余部分少于11字节，则该流量应被认为是可疑的;利用此漏洞的攻击可能正在进行中。

注意，Additional Section中的有效记录，包括OPT记录，必须包含至少11字节(\\x00

for Name, 2 bytes for Type, 2 bytes for Class, 4 bytes for TTL, and 2 bytes for RDLENGTH).

##### 规则建议

特征1： 53端口

特征1： 偏移4位匹配 00 01 00 00 00 01 

    说明：

特征2： 00 0C 00 01

说明：00 0c ---- Type: PTR (domain name PoinTeR) (12)

      00 01---- Class: IN (0x0001)

特征3：剩余长度<11

#### CVE-2020-8617

##### 漏洞分析

使用特制消息，如果攻击者知道（或成功猜测）服务器使用的 TSIG 密钥的名称，则攻击者可能会导致 BIND 服务器进入不一致状态。攻击者可以利用 BIND 代码中的错误来检查包含 TSIG 资源记录的消息的有效性，从而触发 tsig.c 中的断言失败，从而导致对客户端的拒绝服务。

##### 规则建议

![](assets/image907.jpg)

特征1： 53端口

特征2： 匹配local-ddns\\x00\\x00\\xfa\\x00\\xff

说明：local-ddns\\x00----Name: local-ddns

      \\x00\\xfa---- Type: TSIG (Transaction Signature) (250)

      \\x00\\xff---- Class: ANY (0x00ff)

特征3：\\x0bhmac-sha256跳过6字节继续匹配\\x01\\x2c

说明： \\x0bhmac-sha256---- Algorithm Name: hmac-sha256

       \\x01\\x2c ---- Fudge: 300
