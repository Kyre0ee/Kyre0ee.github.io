---
layout: post
title: 第六章 数值数据得表示
date: 2019-05-04 15:57 +0800
tags: 计组-MIPS汇编
excerpt: "整数以及浮点数运算的学习笔记"
toc: true
---
# 第六章
***
## 1.整数的表示
![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/3a88f4a3-3b3f-4b0a-8a80-6255b179e25a)
机器级数据分为两大类：
   - 数值数据：无符号整数、带符号整数、浮点数、十进制数
   - 非数值数据：逻辑数、西文字符和汉字
计算机内部所有信息都用二进制（即：0和1）进行编码
用二进制编码得原因：制造二个稳定态得物理器件容易，二进制编码计数运算规则简单，正好与逻辑命题对应，便于逻辑运算，并可方便地用逻辑电路实现算术运算。
真值和机器数：
   - 机器数：用0和1编码的计算机内部的0/1序列
   - 真值：机器数真正的值，即：现实中带正负号的数。
数值数据表示的三要素：
    进位计数制、定浮点表示、如何用二进制编码
    即：要确定一个数值数据的值必须先确定这三个要素。
进位计数制：十进制、二进制、十六进制、八进制及其相互转换
定/浮点表示（解决小数点问题）
    定点整数、定点小数、浮点数（可用一个定点小数和一个定点整数来表示）
定点数编码（解决正负号问题）
    原码、补码、反码、移码（反码很少用）

1.原码表示：

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/40c5bd16-d3bc-49f9-b79d-b79d77f2605d)

    1.容易理解
    2.0的表示不唯一，故不利于程序员编程
    3.加减运算方式不统一
    4.需额外对符号位进行处理，故不利于硬件设计
    5.特别当a<b时，实现a-b比较困难
2.补码表示：
重要概念：在一个模运算系统中，一个数与它除以模后的余数等价
结论1：一个负数的补码等于模减该负数的绝对值
结论2：对于某一个确定的模，某数减去小于模的另一数，总可以用该数加上另一数负数的补码来代替。
补码运算：+ 和-的统一
运算器是一个模运算系统，适合用补码表示和运算：计算机中运算器只有有限位。假定为n位，则运算结果只能保留低n位，故可看成是个只有n档的二进制算盘。所以，其模为2^n

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/30e2072e-6100-4fb0-84f8-70ae3e0f58cc)

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/ddd06a49-6c1a-427c-8dbf-5800e6946b7f)
   正数：符号位为0，数值部分不变
   负数：符号位为1，数值部分各位取反，末位加1
   变形（模4）补码：双符号，用于存放可溢出的中间结果。


![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/dc7f47a4-0686-47c5-b729-bf4c05e59965)
符号为0，则为正数，数值部分同。符号为1，则为负数，数值各位取反，末位加1

无符号整数：
   一般在全部是正数运算且不出现负值结果的场合下，可使用无符号数表示。例如:地址运算，编号表示，等等。
   无符号数的编码中没有符号位。
   能表示的最大值大于位数相同的带符号整数的最大值。例如，8位无符号整数最大是255、而8位带符号整数最大为127。
   总是整数，所以很多时候就简称为无符号数。
带符号整数：
   计算机必须能处理正数和负数，MSB表示数符
   有三种定点编码方式：
       原码：现用来表示浮点实数的尾数
       反码：现已不用于表示数值数据
       补码：50年代以来，所有计算机都用补码来表示定点整数
   为什么用补码表示带符号整数？
       补码运算系统是模运算系统，加、减运算统一
       数0的表示唯一，方便使用
       比原码和反码多表示一个最小负数
       与移码相比，其符号位和真值的符号对应关系清楚。
带符号数和无符号数的比较
    扩充操作有差别
    ![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/1c0682e9-3b6e-4f03-986e-ccc9986cbf23)
        MIPS提供了两种加载指令：- 无符号数：lbu $t0,0($s0); - 带符号数： lb $t0,0($s0)
    数的比较有差异
        
    溢出判断有差异（无符号数根据最高位是否有进位判断溢出，通常不判）
       MIPS规定：无符号数运算溢出时，不产生溢出异常。
    若同时有无符号和带符号整数，则C编译器将带符号整数强制转换为无符号数。
## 2.浮点数的表示

![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/dedbc5b5-0ac3-428b-8663-47485ef86aad)
只要对尾数和指数分别编码，就可以表示一个浮点数。
浮点数的表示范围
![image](https://github.com/Kyre0ee/Kyre0ee.github.io/assets/170155695/fdd53e99-8d0e-4b49-a201-684a02247f23)
科学计数法与浮点数
* 规格化：小数点前只有一位非0数
* 浮点数的表示范围：浮点数范围比定点数大，但数的个数没变多，故数之间更稀疏，且不均匀
* 规格化数形式：小数点前面总是1，故可隐含表示
* 为解决浮点数表示格式不统一制定了浮点数标准IEEE754
  - Sign bit（符号位）：1表示负数  0表示正数
  - Exponent（阶码/指数）
    + 单精度（SP）规格化数阶码范围为00000001（-126）~11111110（127），全0和全1表示特殊值 
	+ bias为127（single）1023（double）
  - Significand(尾数)
    + 规格化尾数最高位总是1，所以隐含表示，省一位
	+ 1 + 23bits（single）,1+52bits(double)
* 在规格化数中，除数为0的结果是+/- ∞，不是溢出异常。为什么这个处理？可以利用+∞/-∞作比较，解码全1，尾数全0
* 非数NaN
十进制数的表示
  * 计算机中为什么要用十进制数表示数值？日常使用的都是十进制数，所以，计算机外部都使用十进制数。在一些有大量数据输入输出的系统中，为减少二进制数和十进制数之间的转换，在计算机内部之间用十进制数表示数值。
  * 数值数据的两种表示
    - 二进制数
      + 定点正数：无符号和有符号
      + 浮点数
    - 十进制数
      + 用ASCII码表示
        - 前分隔数字串：符号位单独用一个字节表示，位于数字串之前。正号用“+”的AscII码（2BH）;负号用“-”的ASCII码（2DH）表示
        - 后嵌入数字串：符号位嵌入最低位数字的ASCII码高4位中。比前分隔方式省一个字节。正数不变，负数高四位变为0111
      + 用BCD码表示
## 3.非数值数据的表示和数据的排列纠检错
* 逻辑数据的编码表示
  - 表示：用1位表示，例如真1假0，N位二进制数可表示N个逻辑数据，或一个位串
  - 运算：按位运算，如按位与/或/逻辑左移/逻辑右移等
  - 识别：逻辑数据和数值数据在形式上并无差别，也是一串0/1序列，机器靠指令来识别
  - 位串：用来表示若干个状态位或控制位（操作系统中使用较多）如X86的标志寄存器
* 西文字符的编码表示
  - 特点：是一种拼音文字，用有限几个字母可拼出所有单词，只对有限个字母和数学符号、标点符等辅助字符编码、所有字符总数不超过256个，使用7或8个二进位可表示
  - 表示：常用编码为7位ASCII码（十进制数字、英文字母、专用符号、控制字符）
  - 操作：字符串操作，如：传送/比较等
* 汉字及国际字符的编码表示
  - 特点：汉字是表意文字，一个字就是一个方块图形。汉字数量巨大，总数超过6万字，给汉字在计算机内部的表示、汉字的传输与交换、汉字的输入和输出等带来了一系列问题。
  - 编码形式：输入码：对汉字用相应按键进行编码表示，用于输入。内码：用于对系统中进行存储、查找传送等处理。字模点阵或轮廓描述：描述汉字字模点阵或轮廓用于显示打印。
## 4.数据的校验
## 5.计算机中的运算概述
## 6.定点加减乘运算
## 7.定点除运算
## 8.浮点数运算
# 第六章 总结
***
