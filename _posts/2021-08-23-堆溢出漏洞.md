#### 堆溢出漏洞

##### 堆的工作原理

堆在内存空间中不一定连续，堆可由用户管理。

分配堆的方式在不同系统中不同，我们接下来讨论在linux glibc中的ptmalloc2的实现原理。

本来linux默认的是dlmalloc，但是由于其不支持多线程堆管理，所以后来被支持多线程的ptmalloc2代替了。Linux平台malloc本质上是通过系统调用brk（主线程）或者mmap（子线程）实现的。

本文讨论单线程情况下的堆分配。如下图所示是一个主线程堆状态。

malloc_state是arena Header，Areana Header包含bins的信息、top chunk以及最后一个remainder chunk。当主线程中需要更多堆空间的时候，就通过扩展sbrk的heap segment来获取更多的空间，直到它碰到内存mapping为止。

**chunk 的前后关系只有在bin中是使用fd、bk指针标识的，在内存中连续的chunk则通过 prev_size 和 size 来寻找前后 chunk，当然，这也就造成了漏洞。**

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

上图中，malloc_chunk是chunk header，一个heap可以被分成多个chunk,每个chunk的大小，根据用户请求来决定。（malloc(size) 用户申请size 实际获得 size+headsize）每个chunk都由一个结构体malloc_chunk来表示。

       在glibc malloc中将整个堆内存空间分成了连续的、大小不一的chunk，即对于堆内存管理而言chunk就是最小操作单位。Chunk一共分为4类：1）allocated chunk 2)free chunk

3)top chunk 4)last remainder chunk,所有类型chunk都是内存中一块连续的区域，只有通过该区域中特定位置的某些标识符加以区分。

在堆管理过程中需要用一些数据结构来标志每个块的边界，以及区分已分配块和空闲块。大多数内存管理器将这些边界信息作为chunk的一部分嵌入到chunk内部。

###### Malloc_chunk结构

struct malloc_chunk {

  /* #define INTERNAL_SIZE_T size_t */

  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */

  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* 这两个指针只在free chunk中存在*/

  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */

  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */

  struct malloc_chunk* bk_nextsize;

};

PREV_INUSE(P): 表示前一个chunk是否为allocated。

IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。

NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。

Fd: 指向binlist中的下一个chunk

BK: 指向binlist中的前一个chunk

###### Top chunk

当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并不属于任何bin，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png)

###### Allocated chunk

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image005.jpg)

注意： 这里的上一块表示在内存的堆中连续的chunk的上一块，区别bin中的前后关系。

###### Free chunk的管理

bin是一种记录free chunk的链表数据结构。系统针对不同大小的free chunk，将bin分为了4类：1) Fast bin; 2) Unsorted bin; 3) Small bin; 4) Large bin。

       在glibc中用于记录bin的数据结构有两种，分别如下所示：

FastbinsY:用于记录所有fast bins的数组。Bins:用于记录所有除fast bins之外的所有bins。（事实上一共有126个bins,分别是bin1为unsorted bin;bin 2 到63为small bin;bin 64到126为large bin。）

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)

Fast bin

Chunk size 为16到80字节的chunk叫做fast chunk。（chunk size表示malloc chunk的实际整体大小包括prev_size\size\fd\bk等辅助成员的大小）

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)

Fast bin的个数有10个，每个fast bin都是一个单链表（只是用fd指针）。Free时将新fast chunk加入链表尾，malloc时从fast chunk链表尾部进行获取。（注意，fastbinsY数组中每个fastbin元素都指向该链表的尾节点，尾节点通过其fd指向前一个节点，即链表中的下一个节点。）

Fast bin中包含的fast chunk size是按照步进8字节排序的。（16、24…80）,因为fast bin 设计的初衷就是进行快速的小内存分配和释放，所以系统不会对相邻的fast bin中的free chunk进行合并。（系统将属于fast bin的chunk的P总是置为1）。

在初始化fast bin的时候fast bin支持的最大内存以及所有fast bin链表都为空，这个时候申请大小属于fast chunk的内存大小不会交给fast bin处理，而是向下传递交由small bin处理，如果small bin也为空就交给unsorted bin处理。

Bins

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

       Unsorted bin

暂时存储free后的chunk，一段时间后会将chunk放入对应的bin中。

只有一组（free chunks组成的循环双链表），在unsorted bin中，对chunk的大小没有限制，任何大小的chunk都可以归属到unsorted bin中。

       Small bin

包含62组(也是由free chunks组成的循环双链表)，同一个small bin中所有的chunk大小是一样的。（第一个small bin中的chunk大小为16字节，后续依次增加8字节最后一个是508字节）。

       Large bin

包含63组（循环双链表）同一个large bin中的每个chunk大小可以不一样，但处于给定的范围，large chunk可以添加、删除在large bin中的任何一个位置。（前32个large bin依次以64字节步长为间隔，紧随其后的16个以512字节步长为间隔；之后的8个以4096为间隔；在之后4个以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。）鉴于，同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中所有的chunk按照chunk size 从大到小排列，最大的chunk 放在链表头，最小chunk放在链表尾。

Large bin释放的时候，首先确定用户请求的大小的属于哪一个large bin,然后判断该large bin中最大的chunk的size是否大于用户请求的size。如果大于，就从rear end开始遍历该large bin,找到第一个size相等或接近的chunk。分配给用户，如果该chunk 大于用户请求的size的话，就将该chunk 拆分成两个chunk：前者返回给用户，剩余的部分作为一个新的chunk添加到unsorted bin中。

       合并操作：相邻的free chunk(除fast bin)是需要进行合并的，合并成一个大的free chunk.

当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，最后将新的chunk添加到unsorted bin中。当释放较小或较大的chunk时，系统不会把它们添加到对应的bins中，而是将它们添加到unsorted bin中。目的是为了让glibc malloc机制有第二次机会重新利用最近释放的chunk（第一次机会是fast bin机制从链表尾部取）。利用unsorted bin，可以加快内存的分配和释放（不用使用额外时间去查找合适的bin了）。

       Malloc操作：Small bin以及large bin申请类似于fast bins，最初所有的samll bin都为空，因此在对这些small bin完成初始化之前，会先交由unsorted bin处理，如果unsorted bin也不处理，glibc malloc会依次遍历后续的所有bins,找到第一个满足要求的bin,如果所有的bin都不满足的话，就转而使用top chunk.

Last Remainder chunk

从free chunk中malloc时，如果该chunk足够大，那么将其分为两部分，未分配的放到last remainder中交由unsorted bin管理。

1）Last Remainder chunk如何产生？

当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。

2）Last Remainder chunk的作用是什么？

此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。

当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。

###### Malloc机制

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg)

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg)

###### Free 机制

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg)

###### 其他情况

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg)

##### UAF实验

###### 源码&原理分析

原理： free掉chunk后，指向该chunk的指针还能正常使用

源码：

![Image(20)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image019.png)

###### 调试过程

调用free函数之前

![Image(21)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image021.png)

调用free函数后将0x4042a0放入了tcache中

![Image(22)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image022.png)

malloc新的chunk，直接从tcache中进行分配

![Image(23)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image023.png)

对q->data进行赋值

![7A166665](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image024.png)

继续运行call rdx 其中rdx指向shell的地址

![Image(25)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image025.png)

成功执行预留的后门程序

![Image(26)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image027.png)

##### Unlink利用实验

###### 源码&原理分析

源码：

![Image(1)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image029.png)

原理：在堆上伪造释放一个在使用的chunk，在释放过程进行任意地址写入。

系统通过unlink宏将free chunk从链表中取出（并不是所有从链表中取出chunk的操作都利用到了unlink宏）

![Image(2)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image031.png)

申请了两个chunk,并利用第一个chunk溢出到第二个chunk的size位，将第一个chunk的inuse位改为free状态，这时候我们再free 第二个chunk，此时系统会通过第二个chunk的size检查第一个chunk，发现他是free状态，那么这时候就会使用unlink将第一块从bin中释放出来与第二块合并。

此时第一个chunk已经不在bin中了，但是我们却仍然可以使用第一个chunk的fd和bk指针元素，就进一步可以造成进行任意地址写入。

![Image(3)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image032.png)

在构造的时候有如下检查，我们可以进行构造绕过。

![](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image033.png)

使得chunk0_ptr[3]存放的是chunk0_ptr[0]的地址，那么向chunk0_ptr[3]中写入数据也就是向chunk0_ptr[0]中写入数据了。接下来就可以利用两次写入造成任意地址写入。在chunk0_ptr[3]中放入我们想写入的地址，在利用chunk0_ptr[0]进行写入就可以修改该地址处的数据了。（比如修改got表地址，就是对上一次写入的地址进行任意修改）。

###### 调试过程

执行完chunk0_ptr构造之后chunk0_ptr中的值

![Image(4)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image035.png)

调用free(chunk1_ptr)

![heap_unlink1_调用free后chunk0_ptr位置改变](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image037.png)![Image(5)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image039.png)

0x404000位置是：libc_free在GOT表项中的位置

![Image(6)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image040.png)

chunk0_ptr[0]将GPT表项中free函数的值修改为了win函数的地址

![Image(7)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image041.png)

调用free(chunk3_ptr)前

![Image(8)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image043.png)

跳转到#0x404000<free@got[plt]>

![heap_unlink1_GOT表项free位置值被改](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image045.png)

继续单步执行，可以看到已经进入了win函数

![Image(9)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image047.png)

继续执行成功获取了flag.txt文件中保存的值。

![Image(10)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image049.png)

##### House of spirit实验

###### 源码&原理分析

源码：

![Image(27)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image050.png)

原理图：

![Image(28)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image051.png)

原理:在栈上伪造一个chunk结构，利用free进行释放，再次malloc得到这个chunk，可以对这个chunk进行写入，构造的这个chunk中间包括返回地址等重要信息。

假设在栈上给有一个数组可以用来填充数据（password）构造要释放的chunk的size（password[1]）为0x40,为了绕过检查（unlink检查：当前chunk的size是否等于下一个chunk的prev_size）需要在这个chunk后面紧跟一个chunk，设置其size位(0x40/sizeof(unsigned long long) = 8 )  id =>fake_chunks[9] = 0x1234。然后我们把fake_chunk[2]的地址作为参数调用free（chunk中size的下一位为malloc的返回地址）。当再进行malloc的时候就可以获取当前构造的chunk了。

###### 调试过程

构造栈上的数据，使其符合fast_bin chunk

执行完free(victim)之后构造的chunk被放在了tcache中

![Image(29)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image053.png)![Image(30)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image054.png)

继续执行，栈上的返回地址被修改

![Image(31)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image055.png)

程序流程已被改变，成功获取shell

![Image(32)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image057.png)

##### House of lore实验

###### 源码&原理分析

源码：

![F47FDDB4](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image059.png)

原理图：

![Image(34)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image061.png)

在栈上伪造一条small bin链表。首先需要创建一些chunk，第一个chunk用于进入small bin,之后的chunk为了防止free 后被top chunk合并。接下来我们将第一个chunk送入smallbin中，但是在第一次free后它位于unsortedbin中。

如何把第一个chunk放入smallbin中？

调用malloc(1200);当我们申请一个size位于largebin中，并且在unsortedbin中没有与其匹配的chunk，系统依次找完fastbin、smallbin、unsortedbin后发现找不到这个size的chunk，接下来会把unsortedbin中的chunk加入到smallbin或者largebin中，这时，我们的victim就成功进入smallbin中了。

现在如果我们可以控制第一个chunk的fd\bk指针，我们就可以在栈上伪造出一个smallbin链表。然后我们对栈上的数组stack_buffer[1]&stack_buffer[2]进行构造使其进入smallbin链表中，当再次进行malloc申请时就会从smallbin的链表末尾取chunk了。

###### 调试过程

首先malloc 一个victim chunk

![Image(35)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image063.png)

释放victim 此时victim_chunk还在unsortedbin中，我们申请一个大的chunk使其在unsortedbin中找不到

![skitch11](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image065.png)

继续执行可以看到victim_chunk已经被放在了smallbins中

![Image(36)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image066.png)

在栈上构造一个smallbin的链表结构

![Image(37)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image068.png)

继续执行返回地址位置的值已经被覆盖

![Image(38)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image070.png)

继续执行成功进入jackpot函数中执行一个shell

![Image(39)](file:///C:/Users/zhukeyu/AppData/Local/Temp/msohtmlclip1/01/clip_image072.png)