
## C++虚函数

###1.虚函数的作用

为了满足多态和泛型编程，C++允许用户使用虚函数来完成运行时决议这一操作，这与一般的编译时决议有本质区别。

### 2.虚函数的实现原理

虚函数由两部分组成：虚函数指针和虚函数表

只有拥有虚函数的类才会拥有虚函数指针，每一个虚函数对应一个虚函数指针。在一个实例化的对象中，虚函数指针被放在该对象的地址首位，虚函数指针对外部不可见也不可调用的。（除非通过直接访问地址的做法或者在debug模式中。）

虚函数指针本质上是一个指向函数的指针，它指向用户定义的虚函数，当字类调用虚函数时，是通过调用该虚函数指针找到相应的接口。

虚函数指针排列在对象的地址首部按照一定的顺序组织起来，构成了一种表状结构，称为虚函数表。

### 3.基类与派生类的虚表的区别

基类和派生类维护自己的虚表

3.1基类的虚表只记录自己定义的虚函数。

![](../assets/image247.png)

3.2同名覆盖继承：

基类的虚函数表中的同名的虚函数指针会被覆盖。

![](../assets/image248.png)

3.2非覆盖继承

基类的虚函数指针后面跟着字类的虚函数指针。

![](../assets/image249.png)

### 4.Linux ELF虚函数分析

Virtual\_fun.cpp

![](../assets/image251.jpg)

![](../assets/image252.png)

输出结果如下：实例派生类对象时先调用基类构造再调用派生类对象

              覆盖重写的虚函数调用的是派生类的虚函数。没有重写的是基类的虚函数。

![](../assets/image253.png)

查看可执行文件类型：

![](../assets/image255.jpg)

得到基类和派生类的虚表信息：readelf -Ws virtual\_fun | c++filt | grep vtable![](../assets/image257.jpg)

使用gdb进行动态调试：

虚表大小为40，按照5\*8字节查看其内存，前16字节存放的是typeinfo的信息

之后每8字节存放一个虚函数的地址。实际的虚函数表地址\=虚函数表地址+0x10

CBase的虚表信息：

![](../assets/image258.png)

CDerived的虚表信息：（**派生类的虚函数延用基类虚函数的排序规则：有则替换，无则使用基类的，新增则按声明顺序往后排，并不改变原有顺序**）

![](../assets/image260.jpg)

运行start执行：

![](../assets/image261.png)

![](../assets/image263.jpg)

disassemble命令参数：/m指示显示汇编指令的同时，显示相应的程序源码；/r指示显示十六进制的计算机指令，输出按列分别为：虚拟内存地址+偏移+计算机指令+汇编指令

进入到派生类的构造函数可以看到其调用了基类的构造函数

![](../assets/image265.jpg)

![](../assets/image267.jpg)

![](../assets/image269.jpg)

![](../assets/image271.jpg)

![](../assets/image272.png)

![](../assets/image274.jpg)

![](../assets/image276.jpg)