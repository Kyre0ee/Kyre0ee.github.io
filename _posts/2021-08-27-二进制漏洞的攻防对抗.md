### 二进制漏洞的攻防对抗

#### 返回地址&GS选项

守：你不是要覆盖返回地址吗？我在函数执行一开始先往栈上保存一个Security cookie。等函数返回之前先检查这个数据要是不一致那一定是被覆盖了，就不进行返回了。

这一技术可以在**编译器选项**的设置为启用GS选项。一旦校验不通过，函数跳到相应的处理过程，不再返回因此shellcode也就无法获得执行机会。

#### 异常处理SHE链利用&Safe SHE

攻：你别忘了异常处理SHE链也在栈上，我可以通过覆盖SHE链为jmp esp的地址，之后触发异常跳转到jmp esp执行shellcode。

注：利用覆盖SHE链的方法同样是覆盖了栈空间，因此必须满足：在函数检查Security cookie之前就触发异常。为了能够触发异常，1.尽可能多的覆盖栈空间。输入的数据如果足够大，保证覆盖掉SHE链后继续覆盖超出栈空间2.通过控制数据，在函数触发漏洞之后到返回之前的代码中触发异常。

守：你想通过覆盖SHE链实现执行shellcode，那我就修改下溢出的处理机制，在程序编译的时候，就将所有的异常处理函数进行注册。凡是执行过程中触发异常后，都要经过一个检验函数，检查SHE链指向的地址是否在注册的列表中。如果不在，那就不去执行。这个机制被称为safeSEH。

#### 非SHE模块&DEP(数据执行保护)

攻：分析了下它的检测函数逻辑，发现阻止执行情况只有在SHE链指向模块（exe,dll）地址的情况下，如果SHE链指向的地址不在这些模块里，就可以不用执行了，那在程序中非模块的数据中找到jmp esp就可以了。对于不支持js等脚本的软件，在数据空间中寻找jmp esp地址，覆盖she链指向此地址。对于支持js等脚本的软件，直接通过脚本申请堆空间写入shellcode,覆盖SHE链指向堆上的shellcode地址。

守：我不信防不住，我直接上大招，数据执行保护（DEP）让堆和栈只有读写权限没有执行权限。

#### ROP&地址空间随机化（ASLR）

攻：shellcode还在栈中，如果可以从程序自身的代码中去凑到代码将shellcode所在的内存属性添加上可执行权限就可以了，这种利用程序自身的代码碎片绕过DEP的技术称为ROP。

守：ROP技术的前提是代码片段的地址固定，这样才能知道往函数返回值或者SHE链中填写那个地址。那我把地址空间布局随机化（ASLR）让exe,dll的地址都随机。

#### Heap Spraying堆喷射&ASLR+DEP的双重防护

攻：是在不行，我们暴力把程序空间占满，全铺上shellcode,只要跳转地址没落在已有模块，落在我们的空间中不就可以执行shellcode了吗。堆喷射通过大面积的申请内存空间并构造适当的数据，一旦EIP指向这片空间，就可以执行shellcode。堆喷射已经是不得已而为之，有时候会造成系统卡住，容易被发现，另一点，如果EIP恰好指向shellcode中间部分就会造成漏洞利用失败，因此不能保证一定成功。

守：堆喷射只是绕过了ASLR,无法绕过DEP，对于ASLR+DEP的双重防护依然是无效的。